{"/home/travis/build/npmtest/node-npmtest-blink-diff/test.js":"/* istanbul instrument in package npmtest_blink_diff */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-blink-diff/lib.npmtest_blink_diff.js":"/* istanbul instrument in package npmtest_blink_diff */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_blink_diff = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_blink_diff = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-blink-diff/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-blink-diff && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_blink_diff */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_blink_diff\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_blink_diff.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_blink_diff.rollup.js'] =\n            local.assetsDict['/assets.npmtest_blink_diff.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_blink_diff.__dirname + '/lib.npmtest_blink_diff.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/index.js":"// Copyright 2014-2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar assert = require('assert'),\n\tPNGImage = require('pngjs-image'),\n\tPromise = require('promise');\n\nfunction load(value, defaultValue) {\n\treturn (value == null) ? defaultValue : value;\n}\n\n/**\n * Blink-diff comparison class\n *\n * @constructor\n * @class BlinkDiff\n * @param {object} options\n * @param {PNGImage|Buffer} options.imageA Image object of first image\n * @param {string} options.imageAPath Path to first image\n * @param {PNGImage|Buffer} options.imageB Image object of second image\n * @param {string} options.imageBPath Path to second image\n * @param {string} [options.imageOutputPath=undefined] Path to output image file\n * @param {int} [options.imageOutputLimit=BlinkDiff.OUTPUT_ALL] Determines when an image output is created\n * @param {string} [options.thresholdType=BlinkDiff.THRESHOLD_PIXEL] Defines the threshold of the comparison\n * @param {int} [options.threshold=500] Threshold limit according to the comparison limit.\n * @param {number} [options.delta=20] Distance between the color coordinates in the 4 dimensional color-space that will not trigger a difference.\n * @param {int} [options.outputMaskRed=255] Value to set for red on difference pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputMaskGreen=0] Value to set for green on difference pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputMaskBlue=0] Value to set for blue on difference pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputMaskAlpha=255] Value to set for the alpha channel on difference pixel. 'Undefined' will not change the value.\n * @param {float} [options.outputMaskOpacity=0.7] Strength of masking the pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n * @param {int} [options.outputShiftRed=255] Value to set for red on shifted pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputShiftGreen=165] Value to set for green on shifted pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputShiftBlue=0] Value to set for blue on shifted pixel. 'Undefined' will not change the value.\n * @param {int} [options.outputShiftAlpha=255] Value to set for the alpha channel on shifted pixel. 'Undefined' will not change the value.\n * @param {float} [options.outputShiftOpacity=0.7] Strength of masking the shifted pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n * @param {int} [options.outputBackgroundRed=0] Value to set for red as background. 'Undefined' will not change the value.\n * @param {int} [options.outputBackgroundGreen=0] Value to set for green as background. 'Undefined' will not change the value.\n * @param {int} [options.outputBackgroundBlue=0] Value to set for blue as background. 'Undefined' will not change the value.\n * @param {int} [options.outputBackgroundAlpha=undefined] Value to set for the alpha channel as background. 'Undefined' will not change the value.\n * @param {float} [options.outputBackgroundOpacity=0.6] Strength of masking the pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n * @param {object|object[]} [options.blockOut] Object or list of objects with coordinates of blocked-out areas.\n * @param {int} [options.blockOutRed=0] Value to set for red on blocked-out pixel. 'Undefined' will not change the value.\n * @param {int} [options.blockOutGreen=0] Value to set for green on blocked-out pixel. 'Undefined' will not change the value.\n * @param {int} [options.blockOutBlue=0] Value to set for blue on blocked-out pixel. 'Undefined' will not change the value.\n * @param {int} [options.blockOutAlpha=255] Value to set for the alpha channel on blocked-out pixel. 'Undefined' will not change the value.\n * @param {float} [options.blockOutOpacity=1.0] Strength of masking the blocked-out pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n * @param {boolean} [options.copyImageAToOutput=true]  Copies the first image to the output image before the comparison begins. This will make sure that the output image will highlight the differences on the first image.\n * @param {boolean} [options.copyImageBToOutput=false] Copies the second image to the output image before the comparison begins. This will make sure that the output image will highlight the differences on the second image.\n * @param {string[]} [options.filter=[]] Filters that will be applied before the comparison. Available filters are: blur, grayScale, lightness, luma, luminosity, sepia\n * @param {boolean} [options.debug=false] When set, then the applied filters will be shown on the output image.\n * @param {boolean} [options.composition=true] Should a composition be created to compare?\n * @param {boolean} [options.composeLeftToRight=false] Create composition from left to right, otherwise let it decide on its own whats best\n * @param {boolean} [options.composeTopToBottom=false] Create composition from top to bottom, otherwise let it decide on its own whats best\n * @param {boolean} [options.hideShift=false] Hides shift highlighting by using the background color instead\n * @param {int} [options.hShift=2] Horizontal shift for possible antialiasing\n * @param {int} [options.vShift=2] Vertical shift for possible antialiasing\n * @param {object} [options.cropImageA=null] Cropping for first image (default: no cropping)\n * @param {int} [options.cropImageA.x=0] Coordinate for left corner of cropping region\n * @param {int} [options.cropImageA.y=0] Coordinate for top corner of cropping region\n * @param {int} [options.cropImageA.width] Width of cropping region (default: Width that is left)\n * @param {int} [options.cropImageA.height] Height of cropping region (default: Height that is left)\n * @param {object} [options.cropImageB=null] Cropping for second image (default: no cropping)\n * @param {int} [options.cropImageB.x=0] Coordinate for left corner of cropping region\n * @param {int} [options.cropImageB.y=0] Coordinate for top corner of cropping region\n * @param {int} [options.cropImageB.width] Width of cropping region (default: Width that is left)\n * @param {int} [options.cropImageB.height] Height of cropping region (default: Height that is left)\n * @param {boolean} [options.perceptual=false] Turns perceptual comparison on\n * @param {float} [options.gamma] Gamma correction for all colors\n * @param {float} [options.gammaR] Gamma correction for red\n * @param {float} [options.gammaG] Gamma correction for green\n * @param {float} [options.gammaB] Gamma correction for blue\n *\n * @property {PNGImage} _imageA\n * @property {PNGImage} _imageACompare\n * @property {string} _imageAPath\n * @property {PNGImage} _imageB\n * @property {PNGImage} _imageBCompare\n * @property {string} _imageBPath\n * @property {PNGImage} _imageOutput\n * @property {string} _imageOutputPath\n * @property {int} _imageOutputLimit\n * @property {string} _thresholdType\n * @property {int} _threshold\n * @property {number} _delta\n * @property {int} _outputMaskRed\n * @property {int} _outputMaskGreen\n * @property {int} _outputMaskBlue\n * @property {int} _outputMaskAlpha\n * @property {float} _outputMaskOpacity\n * @property {int} _outputShiftRed\n * @property {int} _outputShiftGreen\n * @property {int} _outputShiftBlue\n * @property {int} _outputShiftAlpha\n * @property {float} _outputShiftOpacity\n * @property {int} _outputBackgroundRed\n * @property {int} _outputBackgroundGreen\n * @property {int} _outputBackgroundBlue\n * @property {int} _outputBackgroundAlpha\n * @property {float} _outputBackgroundOpacity\n * @property {object[]} _blockOut\n * @property {int} _blockOutRed\n * @property {int} _blockOutGreen\n * @property {int} _blockOutBlue\n * @property {int} _blockOutAlpha\n * @property {float} _blockOutOpacity\n * @property {boolean} _copyImageAToOutput\n * @property {boolean} _copyImageBToOutput\n * @property {string[]} _filter\n * @property {boolean} _debug\n * @property {boolean} _composition\n * @property {boolean} _composeLeftToRight\n * @property {boolean} _composeTopToBottom\n * @property {int} _hShift\n * @property {int} _vShift\n * @property {object} _cropImageA\n * @property {int} _cropImageA.x\n * @property {int} _cropImageA.y\n * @property {int} _cropImageA.width\n * @property {int} _cropImageA.height\n * @property {object} _cropImageB\n * @property {int} _cropImageB.x\n * @property {int} _cropImageB.y\n * @property {int} _cropImageB.width\n * @property {int} _cropImageB.height\n * @property {object} _refWhite\n * @property {boolean} _perceptual\n * @property {float} _gamma\n * @property {float} _gammaR\n * @property {float} _gammaG\n * @property {float} _gammaB\n */\nfunction BlinkDiff (options) {\n\n\tthis._imageA = options.imageA;\n\tthis._imageAPath = options.imageAPath;\n\tassert.ok(options.imageAPath || options.imageA, \"Image A not given.\");\n\n\tthis._imageB = options.imageB;\n\tthis._imageBPath = options.imageBPath;\n\tassert.ok(options.imageBPath || options.imageB, \"Image B not given.\");\n\n\tthis._imageOutput = null;\n\tthis._imageOutputPath = options.imageOutputPath;\n\tthis._imageOutputLimit = load(options.imageOutputLimit, BlinkDiff.OUTPUT_ALL);\n\n\t// Pixel or Percent\n\tthis._thresholdType = load(options.thresholdType, BlinkDiff.THRESHOLD_PIXEL);\n\n\t// How many pixels different to ignore.\n\tthis._threshold = load(options.threshold, 500);\n\n\tthis._delta = load(options.delta, 20);\n\n\tthis._outputMaskRed = load(options.outputMaskRed, 255);\n\tthis._outputMaskGreen = load(options.outputMaskGreen, 0);\n\tthis._outputMaskBlue = load(options.outputMaskBlue, 0);\n\tthis._outputMaskAlpha = load(options.outputMaskAlpha, 255);\n\tthis._outputMaskOpacity = load(options.outputMaskOpacity, 0.7);\n\n\tthis._outputBackgroundRed = load(options.outputBackgroundRed, 0);\n\tthis._outputBackgroundGreen = load(options.outputBackgroundGreen, 0);\n\tthis._outputBackgroundBlue = load(options.outputBackgroundBlue, 0);\n\tthis._outputBackgroundAlpha = options.outputBackgroundAlpha;\n\tthis._outputBackgroundOpacity = load(options.outputBackgroundOpacity, 0.6);\n\n\tif (options.hideShift) {\n\t\tthis._outputShiftRed = this._outputBackgroundRed;\n\t\tthis._outputShiftGreen = this._outputBackgroundGreen;\n\t\tthis._outputShiftBlue = this._outputBackgroundBlue;\n\t\tthis._outputShiftAlpha = this._outputBackgroundAlpha;\n\t\tthis._outputShiftOpacity = this._outputBackgroundOpacity;\n\n\t} else {\n\t\tthis._outputShiftRed = load(options.outputShiftRed, 200);\n\t\tthis._outputShiftGreen = load(options.outputShiftGreen, 100);\n\t\tthis._outputShiftBlue = load(options.outputShiftBlue, 0);\n\t\tthis._outputShiftAlpha = load(options.outputShiftAlpha, 255);\n\t\tthis._outputShiftOpacity = load(options.outputShiftOpacity, 0.7);\n\t}\n\n\tthis._blockOut = load(options.blockOut, []);\n\tif (typeof this._blockOut != 'object' && (this._blockOut.length !== undefined)) {\n\t\tthis._blockOut = [this._blockOut];\n\t}\n\n\tthis._blockOutRed = load(options.blockOutRed, 0);\n\tthis._blockOutGreen = load(options.blockOutGreen, 0);\n\tthis._blockOutBlue = load(options.blockOutBlue, 0);\n\tthis._blockOutAlpha = load(options.blockOutAlpha, 255);\n\tthis._blockOutOpacity = load(options.blockOutOpacity, 1.0);\n\n\tthis._copyImageAToOutput = load(options.copyImageAToOutput, true);\n\tthis._copyImageBToOutput = load(options.copyImageBToOutput, false);\n\n\tthis._filter = load(options.filter, []);\n\n\tthis._debug = load(options.debug, false);\n\n\tthis._composition = load(options.composition, true);\n\tthis._composeLeftToRight = load(options.composeLeftToRight, false);\n\tthis._composeTopToBottom = load(options.composeTopToBottom, false);\n\n\tthis._hShift = load(options.hShift, 2);\n\tthis._vShift = load(options.vShift, 2);\n\n\tthis._cropImageA = options.cropImageA;\n\tthis._cropImageB = options.cropImageB;\n\n\t// Prepare reference white\n\tthis._refWhite = this._convertRgbToXyz({c1: 1, c2: 1, c3: 1, c4: 1});\n\n\tthis._perceptual = load(options.perceptual, false);\n\n\tthis._gamma = options.gamma;\n\tthis._gammaR = options.gammaR;\n\tthis._gammaG = options.gammaG;\n\tthis._gammaB = options.gammaB;\n}\n\n\n/**\n * Version of class\n *\n * @static\n * @property version\n * @type {string}\n */\nBlinkDiff.version = require('./package.json').version;\n\n\n/**\n * Threshold-type for pixel\n *\n * @static\n * @property THRESHOLD_PIXEL\n * @type {string}\n */\nBlinkDiff.THRESHOLD_PIXEL = 'pixel';\n\n/**\n * Threshold-type for percent of all pixels\n *\n * @static\n * @property THRESHOLD_PERCENT\n * @type {string}\n */\nBlinkDiff.THRESHOLD_PERCENT = 'percent';\n\n\n/**\n * Unknown result of the comparison\n *\n * @static\n * @property RESULT_UNKNOWN\n * @type {int}\n */\nBlinkDiff.RESULT_UNKNOWN = 0;\n\n/**\n * The images are too different\n *\n * @static\n * @property RESULT_DIFFERENT\n * @type {int}\n */\nBlinkDiff.RESULT_DIFFERENT = 1;\n\n/**\n * The images are very similar, but still below the threshold\n *\n * @static\n * @property RESULT_SIMILAR\n * @type {int}\n */\nBlinkDiff.RESULT_SIMILAR = 7;\n\n/**\n * The images are identical (or near identical)\n *\n * @static\n * @property RESULT_IDENTICAL\n * @type {int}\n */\nBlinkDiff.RESULT_IDENTICAL = 5;\n\n\n/**\n * Create output when images are different\n *\n * @static\n * @property OUTPUT_DIFFERENT\n * @type {int}\n */\nBlinkDiff.OUTPUT_DIFFERENT = 10;\n\n/**\n * Create output when images are similar or different\n *\n * @static\n * @property OUTPUT_SIMILAR\n * @type {int}\n */\nBlinkDiff.OUTPUT_SIMILAR = 20;\n\n/**\n * Force output of all comparisons\n *\n * @static\n * @property OUTPUT_ALL\n * @type {int}\n */\nBlinkDiff.OUTPUT_ALL = 100;\n\n\nBlinkDiff.prototype = {\n\n\t/**\n\t * Runs the comparison with a promise\n\t *\n\t * @method runWithPromise\n\t * @example\n\t *     var blinkDiff = BlinkDiff(...);\n\t *     blinkDiff.runWithPromise().then(function (result) {\n     *       ...\n     *     });\n\t * @return {Promise}\n\t */\n\trunWithPromise: function () {\n\t\treturn Promise.denodeify(this.run).call(this);\n\t},\n\n\t/**\n\t * Runs the comparison in node-style\n\t *\n\t * @method run\n\t * @example\n\t *     var blinkDiff = BlinkDiff(...);\n\t *     blinkDiff.run(function (err, result) {\n     *       if (err) {\n     *         throw err;\n     *       }\n     *\n     *       ...\n     *     });\n\t *\n\t * @param {function} fn\n\t */\n\trun: function (fn) {\n\n\t\tvar promise = Promise.resolve(), result;\n\n\t\tPNGImage.log = function (text) {\n\t\t\tthis.log('ERROR: ' + text);\n\t\t\tthrow new Error('ERROR: ' + text);\n\t\t}.bind(this);\n\n\t\tpromise.then(function () {\n\t\t\treturn this._loadImage(this._imageAPath, this._imageA);\n\n\t\t}.bind(this)).then(function (imageA) {\n\t\t\tthis._imageA = imageA;\n\t\t\treturn this._loadImage(this._imageBPath, this._imageB);\n\n\t\t}.bind(this)).then(function (imageB) {\n\n\t\t\tvar gamma, i, len, rect, color;\n\n\t\t\tthis._imageB = imageB;\n\n\t\t\t// Crop images if requested\n\t\t\tif (this._cropImageA) {\n\t\t\t\tthis._correctDimensions(this._imageA.getWidth(), this._imageA.getHeight(), this._cropImageA);\n\t\t\t\tthis._crop(\"Image-A\", this._imageA, this._cropImageA);\n\t\t\t}\n\t\t\tif (this._cropImageB) {\n\t\t\t\tthis._correctDimensions(this._imageB.getWidth(), this._imageB.getHeight(), this._cropImageB);\n\t\t\t\tthis._crop(\"Image-B\", this._imageB, this._cropImageB);\n\t\t\t}\n\n\t\t\t// Always clip\n\t\t\tthis._clip(this._imageA, this._imageB);\n\n\t\t\tthis._imageOutput = PNGImage.createImage(this._imageA.getWidth(), this._imageA.getHeight());\n\n\t\t\t// Make a copy when not in debug mode\n\t\t\tif (this._debug) {\n\t\t\t\tthis._imageACompare = this._imageA;\n\t\t\t\tthis._imageBCompare = this._imageB;\n\t\t\t} else {\n\t\t\t\tthis._imageACompare = PNGImage.copyImage(this._imageA);\n\t\t\t\tthis._imageBCompare = PNGImage.copyImage(this._imageB);\n\t\t\t}\n\n\t\t\t// Block-out\n\t\t\tcolor = {\n\t\t\t\tred: this._blockOutRed,\n\t\t\t\tgreen: this._blockOutGreen,\n\t\t\t\tblue: this._blockOutBlue,\n\t\t\t\talpha: this._blockOutAlpha,\n\t\t\t\topacity: this._blockOutOpacity\n\t\t\t};\n\t\t\tfor (i = 0, len = this._blockOut.length; i < len; i++) {\n\t\t\t\trect = this._blockOut[i];\n\n\t\t\t\t// Make sure the block-out parameters fit\n\t\t\t\tthis._correctDimensions(this._imageACompare.getWidth(), this._imageACompare.getHeight(), rect);\n\n\t\t\t\tthis._imageACompare.fillRect(rect.x, rect.y, rect.width, rect.height, color);\n\t\t\t\tthis._imageBCompare.fillRect(rect.x, rect.y, rect.width, rect.height, color);\n\t\t\t}\n\n\t\t\t// Copy image to composition\n\t\t\tif (this._copyImageAToOutput) {\n\t\t\t\tthis._copyImage(this._debug ? this._imageACompare : this._imageA, this._imageOutput);\n\t\t\t} else if (this._copyImageBToOutput) {\n\t\t\t\tthis._copyImage(this._debug ? this._imageBCompare : this._imageB, this._imageOutput);\n\t\t\t}\n\n\t\t\t// Apply all filters\n\t\t\tthis._imageACompare.applyFilters(this._filter);\n\t\t\tthis._imageBCompare.applyFilters(this._filter);\n\n\t\t\t// Gamma correction\n\t\t\tif (this._gamma || this._gammaR || this._gammaG || this._gammaB) {\n\t\t\t\tgamma = {\n\t\t\t\t\tr: this._gammaR || this._gamma, g: this._gammaG || this._gamma, b: this._gammaB || this._gamma\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Comparison\n\t\t\tresult = this._compare(this._imageACompare, this._imageBCompare, this._imageOutput, this._delta, { // Output-Mask color\n\t\t\t\t\tred: this._outputMaskRed,\n\t\t\t\t\tgreen: this._outputMaskGreen,\n\t\t\t\t\tblue: this._outputMaskBlue,\n\t\t\t\t\talpha: this._outputMaskAlpha,\n\t\t\t\t\topacity: this._outputMaskOpacity\n\t\t\t\t}, { // Output-Shift color\n\t\t\t\t\tred: this._outputShiftRed,\n\t\t\t\t\tgreen: this._outputShiftGreen,\n\t\t\t\t\tblue: this._outputShiftBlue,\n\t\t\t\t\talpha: this._outputShiftAlpha,\n\t\t\t\t\topacity: this._outputShiftOpacity\n\t\t\t\t}, { // Background color\n\t\t\t\t\tred: this._outputBackgroundRed,\n\t\t\t\t\tgreen: this._outputBackgroundGreen,\n\t\t\t\t\tblue: this._outputBackgroundBlue,\n\t\t\t\t\talpha: this._outputBackgroundAlpha,\n\t\t\t\t\topacity: this._outputBackgroundOpacity\n\t\t\t\t}, this._hShift, this._vShift, this._perceptual, gamma);\n\n\t\t\t// Create composition if requested\n\t\t\tif (this._debug) {\n\t\t\t\tthis._imageOutput = this._createComposition(this._imageACompare, this._imageBCompare, this._imageOutput);\n\t\t\t} else {\n\t\t\t\tthis._imageOutput = this._createComposition(this._imageA, this._imageB, this._imageOutput);\n\t\t\t}\n\n\t\t\t// Need to write to the filesystem?\n\t\t\tif (this._imageOutputPath && this._withinOutputLimit(result.code, this._imageOutputLimit)) {\n\t\t\t\tthis._imageOutput.writeImage(this._imageOutputPath, function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tfn(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.log(\"Wrote differences to \" + this._imageOutputPath);\n\t\t\t\t\t\tfn(undefined, result);\n\t\t\t\t\t}\n\t\t\t\t}.bind(this));\n\t\t\t} else {\n\t\t\t\tfn(undefined, result);\n\t\t\t}\n\n\t\t}.bind(this)).then(null, function (err) {\n\t\t\tconsole.error(err.stack);\n\t\t\tfn(err);\n\t\t});\n\t},\n\n\t/**\n\t * Runs the comparison synchronously\n\t *\n\t * @method runSync\n\t * @return {Object} Result of comparison { code, differences, dimension, width, height }\n\t */\n\trunSync: function () {\n\n\t\tvar result, gamma, i, len, rect, color;\n\n\t\tPNGImage.log = function (text) {\n\t\t\tthis.log('ERROR: ' + text);\n\t\t\tthrow new Error('ERROR: ' + text);\n\t\t}.bind(this);\n\n\t\ttry {\n\t\t\tthis._imageA = this._loadImageSync(this._imageAPath, this._imageA);\n\t\t\tthis._imageB = this._loadImageSync(this._imageBPath, this._imageB);\n\n\t\t\t// Crop images if requested\n\t\t\tif (this._cropImageA) {\n\t\t\t\tthis._correctDimensions(this._imageA.getWidth(), this._imageA.getHeight(), this._cropImageA);\n\t\t\t\tthis._crop(\"Image-A\", this._imageA, this._cropImageA);\n\t\t\t}\n\t\t\tif (this._cropImageB) {\n\t\t\t\tthis._correctDimensions(this._imageB.getWidth(), this._imageB.getHeight(), this._cropImageB);\n\t\t\t\tthis._crop(\"Image-B\", this._imageB, this._cropImageB);\n\t\t\t}\n\n\t\t\t// Always clip\n\t\t\tthis._clip(this._imageA, this._imageB);\n\n\t\t\tthis._imageOutput = PNGImage.createImage(this._imageA.getWidth(), this._imageA.getHeight());\n\n\t\t\t// Make a copy when not in debug mode\n\t\t\tif (this._debug) {\n\t\t\t\tthis._imageACompare = this._imageA;\n\t\t\t\tthis._imageBCompare = this._imageB;\n\t\t\t} else {\n\t\t\t\tthis._imageACompare = PNGImage.copyImage(this._imageA);\n\t\t\t\tthis._imageBCompare = PNGImage.copyImage(this._imageB);\n\t\t\t}\n\n\t\t\t// Block-out\n\t\t\tcolor = {\n\t\t\t\tred: this._blockOutRed,\n\t\t\t\tgreen: this._blockOutGreen,\n\t\t\t\tblue: this._blockOutBlue,\n\t\t\t\talpha: this._blockOutAlpha,\n\t\t\t\topacity: this._blockOutOpacity\n\t\t\t};\n\t\t\tfor (i = 0, len = this._blockOut.length; i < len; i++) {\n\t\t\t\trect = this._blockOut[i];\n\n\t\t\t\t// Make sure the block-out parameters fit\n\t\t\t\tthis._correctDimensions(this._imageACompare.getWidth(), this._imageACompare.getHeight(), rect);\n\n\t\t\t\tthis._imageACompare.fillRect(rect.x, rect.y, rect.width, rect.height, color);\n\t\t\t\tthis._imageBCompare.fillRect(rect.x, rect.y, rect.width, rect.height, color);\n\t\t\t}\n\n\t\t\t// Copy image to composition\n\t\t\tif (this._copyImageAToOutput) {\n\t\t\t\tthis._copyImage(this._debug ? this._imageACompare : this._imageA, this._imageOutput);\n\t\t\t} else if (this._copyImageBToOutput) {\n\t\t\t\tthis._copyImage(this._debug ? this._imageBCompare : this._imageB, this._imageOutput);\n\t\t\t}\n\n\t\t\t// Apply all filters\n\t\t\tthis._imageACompare.applyFilters(this._filter);\n\t\t\tthis._imageBCompare.applyFilters(this._filter);\n\n\t\t\t// Gamma correction\n\t\t\tif (this._gamma || this._gammaR || this._gammaG || this._gammaB) {\n\t\t\t\tgamma = {\n\t\t\t\t\tr: this._gammaR || this._gamma, g: this._gammaG || this._gamma, b: this._gammaB || this._gamma\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Comparison\n\t\t\tresult = this._compare(this._imageACompare, this._imageBCompare, this._imageOutput, this._delta,\n\t\t\t\t{ // Output-Mask color\n\t\t\t\t\tred: this._outputMaskRed,\n\t\t\t\t\tgreen: this._outputMaskGreen,\n\t\t\t\t\tblue: this._outputMaskBlue,\n\t\t\t\t\talpha: this._outputMaskAlpha,\n\t\t\t\t\topacity: this._outputMaskOpacity\n\t\t\t\t}, { // Output-Shift color\n\t\t\t\t\tred: this._outputShiftRed,\n\t\t\t\t\tgreen: this._outputShiftGreen,\n\t\t\t\t\tblue: this._outputShiftBlue,\n\t\t\t\t\talpha: this._outputShiftAlpha,\n\t\t\t\t\topacity: this._outputShiftOpacity\n\t\t\t\t}, { // Background color\n\t\t\t\t\tred: this._outputBackgroundRed,\n\t\t\t\t\tgreen: this._outputBackgroundGreen,\n\t\t\t\t\tblue: this._outputBackgroundBlue,\n\t\t\t\t\talpha: this._outputBackgroundAlpha,\n\t\t\t\t\topacity: this._outputBackgroundOpacity\n\t\t\t\t},\n\t\t\t\tthis._hShift, this._vShift,\n\t\t\t\tthis._perceptual,\n\t\t\t\tgamma\n\t\t\t);\n\n\t\t\t// Create composition if requested\n\t\t\tif (this._debug) {\n\t\t\t\tthis._imageOutput = this._createComposition(this._imageACompare, this._imageBCompare, this._imageOutput);\n\t\t\t} else {\n\t\t\t\tthis._imageOutput = this._createComposition(this._imageA, this._imageB, this._imageOutput);\n\t\t\t}\n\n\t\t\t// Need to write to the filesystem?\n\t\t\tif (this._imageOutputPath && this._withinOutputLimit(result.code, this._imageOutputLimit)) {\n\t\t\t\tthis._imageOutput.writeImageSync(this._imageOutputPath);\n\t\t\t\tthis.log(\"Wrote differences to \" + this._imageOutputPath);\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t} catch (err) {\n\t\t\tconsole.error(err.stack);\n\t\t\tthrow err;\n\t\t}\n\t},\n\n\t/**\n\t * Determines if result is within the output limit\n\t *\n\t * @method _withinOutputLimit\n\t * @param {int} resultCode\n\t * @param {int} outputLimit\n\t * @return {boolean}\n\t * @private\n\t */\n\t_withinOutputLimit: function (resultCode, outputLimit) {\n\t\treturn this._convertResultCodeToRelativeValue(resultCode) <= outputLimit;\n\t},\n\n\t/**\n\t * Converts the result-code to a relative value\n\t *\n\t * @method _convertResultCodeToRelativeValue\n\t * @param {int} resultCode\n\t * @return {int}\n\t * @private\n\t */\n\t_convertResultCodeToRelativeValue: function (resultCode) {\n\n\t\tvar valueMap = {\n\t\t\t0: 0, 1: 10, 7: 20, 5: 30\n\t\t};\n\n\t\treturn valueMap[resultCode] !== undefined ? valueMap[resultCode] : 0;\n\t},\n\n\t/**\n\t * Creates a comparison image\n\t *\n\t * @method _createComposition\n\t * @param {PNGImage} imageA\n\t * @param {PNGImage} imageB\n\t * @param {PNGImage} imageOutput\n\t * @return {PNGImage}\n\t * @private\n\t */\n\t_createComposition: function (imageA, imageB, imageOutput) {\n\n\t\tvar width, height, image = imageOutput;\n\n\t\tif (this._composition) {\n\t\t\twidth = Math.max(imageA.getWidth(), imageB.getWidth());\n\t\t\theight = Math.max(imageA.getHeight(), imageB.getHeight());\n\n\t\t\tif (((width > height) && !this._composeLeftToRight) || this._composeTopToBottom) {\n\t\t\t\timage = PNGImage.createImage(width, height * 3);\n\n\t\t\t\timageA.getImage().bitblt(image.getImage(), 0, 0, imageA.getWidth(), imageA.getHeight(), 0, 0);\n\t\t\t\timageOutput.getImage().bitblt(image.getImage(), 0, 0, imageOutput.getWidth(), imageOutput.getHeight(), 0, height);\n\t\t\t\timageB.getImage().bitblt(image.getImage(), 0, 0, imageB.getWidth(), imageB.getHeight(), 0, height * 2);\n\t\t\t} else {\n\t\t\t\timage = PNGImage.createImage(width * 3, height);\n\n\t\t\t\timageA.getImage().bitblt(image.getImage(), 0, 0, imageA.getWidth(), imageA.getHeight(), 0, 0);\n\t\t\t\timageOutput.getImage().bitblt(image.getImage(), 0, 0, imageOutput.getWidth(), imageOutput.getHeight(), width, 0);\n\t\t\t\timageB.getImage().bitblt(image.getImage(), 0, 0, imageB.getWidth(), imageB.getHeight(), width * 2, 0);\n\t\t\t}\n\t\t}\n\n\t\treturn image;\n\t},\n\n\t/**\n\t * Loads the image or uses the already available image\n\t *\n\t * @method _loadImageSync\n\t * @param {string} path\n\t * @param {PNGImage} image\n\t * @return {PNGImage}\n\t * @private\n\t */\n\t_loadImageSync: function (path, image) {\n\n\t\tif (image instanceof Buffer) {\n\t\t\treturn PNGImage.loadImageSync(image);\n\n\t\t} else if ((typeof path === 'string') && !image) {\n\t\t\treturn PNGImage.readImageSync(path);\n\n\t\t} else {\n\t\t\treturn image;\n\t\t}\n\t},\n\n\t/**\n\t * Loads the image or uses the already available image\n\t *\n\t * @method _loadImage\n\t * @param {string} path\n\t * @param {PNGImage} image\n\t * @return {PNGImage|Promise}\n\t * @private\n\t */\n\t_loadImage: function (path, image) {\n\n\t\tif (image instanceof Buffer) {\n\t\t\treturn Promise.denodeify(PNGImage.loadImage).call(PNGImage, image);\n\n\t\t} else if ((typeof path === 'string') && !image) {\n\t\t\treturn Promise.denodeify(PNGImage.readImage).call(PNGImage, path);\n\n\t\t} else {\n\t\t\treturn image;\n\t\t}\n\t},\n\n\t/**\n\t * Copies one image into another image\n\t *\n\t * @method _copyImage\n\t * @param {PNGImage} imageSrc\n\t * @param {PNGImage} imageDst\n\t * @private\n\t */\n\t_copyImage: function (imageSrc, imageDst) {\n\t\timageSrc.getImage().bitblt(imageDst.getImage(), 0, 0, imageSrc.getWidth(), imageSrc.getHeight(), 0, 0);\n\t},\n\n\n\t/**\n\t * Is the difference above the set threshold?\n\t *\n\t * @method isAboveThreshold\n\t * @param {int} items\n\t * @param {int} [total]\n\t * @return {boolean}\n\t */\n\tisAboveThreshold: function (items, total) {\n\n\t\tif ((this._thresholdType === BlinkDiff.THRESHOLD_PIXEL) && (this._threshold <= items)) {\n\t\t\treturn true;\n\n\t\t} else if (this._threshold <= (items / total)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\n\t/**\n\t * Log method that can be overwritten to modify the logging behavior.\n\t *\n\t * @method log\n\t * @param {string} text\n\t */\n\tlog: function (text) {\n\t\t// Nothing here; Overwrite this to add some functionality\n\t},\n\n\n\t/**\n\t * Has comparison passed?\n\t *\n\t * @method hasPassed\n\t * @param {int} result Comparison result-code\n\t * @return {boolean}\n\t */\n\thasPassed: function (result) {\n\t\treturn ((result !== BlinkDiff.RESULT_DIFFERENT) && (result !== BlinkDiff.RESULT_UNKNOWN));\n\t},\n\n\n\t/**\n\t * Clips the images to the lower resolution of both\n\t *\n\t * @private\n\t * @method _clip\n\t * @param {PNGImage} imageA Source image\n\t * @param {PNGImage} imageB Destination image\n\t */\n\t_clip: function (imageA, imageB) {\n\n\t\tvar minWidth, minHeight;\n\n\t\tif ((imageA.getWidth() != imageB.getWidth()) || (imageA.getHeight() != imageB.getHeight())) {\n\n\t\t\tminWidth = imageA.getWidth();\n\t\t\tif (imageB.getWidth() < minWidth) {\n\t\t\t\tminWidth = imageB.getWidth();\n\t\t\t}\n\n\t\t\tminHeight = imageA.getHeight();\n\t\t\tif (imageB.getHeight() < minHeight) {\n\t\t\t\tminHeight = imageB.getHeight();\n\t\t\t}\n\n\t\t\tthis.log(\"Clipping to \" + minWidth + \" x \" + minHeight);\n\n\t\t\timageA.clip(0, 0, minWidth, minHeight);\n\t\t\timageB.clip(0, 0, minWidth, minHeight);\n\t\t}\n\t},\n\n\t/**\n\t * Crops the source image to the bounds of rect\n\t *\n\t * @method _crop\n\t * @param {string} which Title of image to crop\n\t * @param {PNGImage} image Source image\n\t * @param {object} rect Values for rect\n\t * @param {int} rect.x X value of rect\n\t * @param {int} rect.y Y value of rect\n\t * @param {int} rect.width Width value of rect\n\t * @param {int} rect.height Height value of rect\n\t * @private\n\t */\n\t_crop: function (which, image, rect) {\n\n\t\tthis.log(\"Cropping \" + which + \" from \" + rect.x + \",\" + rect.y + \" by \" + rect.width + \" x \" + rect.height);\n\n\t\timage.clip(rect.x, rect.y, rect.width, rect.height);\n\t},\n\n\t/**\n\t * Correcting area dimensions if necessary\n\t *\n\t * Note:\n\t *  Priority is on the x/y coordinates, and not on the size since the size will then be removed anyways.\n\t *\n\t * @method _correctDimensions\n\t * @param {int} width\n\t * @param {int} height\n\t * @param {object} rect Values for rect\n\t * @param {int} rect.x X value of rect\n\t * @param {int} rect.y Y value of rect\n\t * @param {int} rect.width Width value of rect\n\t * @param {int} rect.height Height value of rect\n\t * @private\n\t */\n\t_correctDimensions: function (width, height, rect) {\n\n\t\t// Set values if none given\n\t\trect.x = rect.x || 0;\n\t\trect.y = rect.y || 0;\n\t\trect.width = rect.width || width;\n\t\trect.height = rect.height || height;\n\n\t\t// Check negative values\n\t\trect.x = Math.max(0, rect.x);\n\t\trect.y = Math.max(0, rect.y);\n\t\trect.width = Math.max(0, rect.width);\n\t\trect.height = Math.max(0, rect.height);\n\n\t\t// Check dimensions\n\t\trect.x = Math.min(rect.x, width - 1); // -1 to make sure that there is an image\n\t\trect.y = Math.min(rect.y, height - 1);\n\t\trect.width = Math.min(rect.width, width - rect.x);\n\t\trect.height = Math.min(rect.height, height - rect.y);\n\t},\n\n\n\t/**\n\t * Calculates the distance of colors in the 4 dimensional color space\n\t *\n\t * @method _colorDelta\n\t * @param {object} color1 Values for color 1\n\t * @param {int} color1.c1 First value of color 1\n\t * @param {int} color1.c2 Second value of color 1\n\t * @param {int} color1.c3 Third value of color 1\n\t * @param {int} color1.c4 Fourth value of color 1\n\t * @param {object} color2 Values for color 2\n\t * @param {int} color2.c1 First value of color 2\n\t * @param {int} color2.c2 Second value of color 2\n\t * @param {int} color2.c3 Third value of color 2\n\t * @param {int} color2.c4 Fourth value of color 2\n\t * @return {number} Distance\n\t * @private\n\t */\n\t_colorDelta: function (color1, color2) {\n\t\tvar c1, c2, c3, c4;\n\n\t\tc1 = Math.pow(color1.c1 - color2.c1, 2);\n\t\tc2 = Math.pow(color1.c2 - color2.c2, 2);\n\t\tc3 = Math.pow(color1.c3 - color2.c3, 2);\n\t\tc4 = Math.pow(color1.c4 - color2.c4, 2);\n\n\t\treturn Math.sqrt(c1 + c2 + c3 + c4);\n\t},\n\n\t/**\n\t * Gets the color of an image by the index\n\t *\n\t * @method _getColor\n\t * @param {PNGImage} image Image\n\t * @param {int} idx Index of pixel in image\n\t * @param {boolean} [perceptual=false]\n\t * @param {object} [gamma]\n\t * @return {object} Color\n\t * @private\n\t */\n\t_getColor: function (image, idx, perceptual, gamma) {\n\n\t\tvar color;\n\n\t\tcolor = {\n\t\t\tc1: image.getRed(idx), c2: image.getGreen(idx), c3: image.getBlue(idx), c4: image.getAlpha(idx)\n\t\t};\n\n\t\tif (perceptual || gamma) {\n\t\t\tcolor = this._correctGamma(color, gamma);\n\t\t\tcolor = this._convertRgbToXyz(color);\n\t\t\tcolor = this._convertXyzToCieLab(color);\n\t\t}\n\n\t\treturn color;\n\t},\n\n\t/**\n\t * Correct gamma and return color in [0, 1] range\n\t *\n\t * @method _correctGamma\n\t * @param {object} color\n\t * @param {object} [gamma]\n\t * @return {{c1: number, c2: number, c3: number, c4: number}}\n\t * @private\n\t */\n\t_correctGamma: function (color, gamma) {\n\n\t\t// Convert to range [0, 1]\n\t\tvar result = {\n\t\t\tc1: color.c1 / 255, c2: color.c2 / 255, c3: color.c3 / 255, c4: color.c4\n\t\t};\n\n\t\tif (gamma || gamma.R !== undefined || gamma.G !== undefined || gamma.B !== undefined) {\n\t\t\tif (gamma.R !== undefined) {\n\t\t\t\tresult.c1 = Math.pow(result.c1, gamma.R);\n\t\t\t}\n\t\t\tif (gamma.G !== undefined) {\n\t\t\t\tresult.c2 = Math.pow(result.c2, gamma.G);\n\t\t\t}\n\t\t\tif (gamma.B !== undefined) {\n\t\t\t\tresult.c3 = Math.pow(result.c3, gamma.B);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts the color from RGB to XYZ\n\t *\n\t * @method _convertRgbToXyz\n\t * @param {object} color\n\t * @return {object}\n\t * @private\n\t */\n\t_convertRgbToXyz: function (color) {\n\t\tvar result = {};\n\n\t\tresult.c1 = color.c1 * 0.4887180 + color.c2 * 0.3106803 + color.c3 * 0.2006017;\n\t\tresult.c2 = color.c1 * 0.1762044 + color.c2 * 0.8129847 + color.c3 * 0.0108109;\n\t\tresult.c3 = color.c2 * 0.0102048 + color.c3 * 0.9897952;\n\t\tresult.c4 = color.c4;\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts the color from XYZ to CieLab\n\t *\n\t * @method _convertXyzToCieLab\n\t * @param {object} color\n\t * @return {object}\n\t * @private\n\t */\n\t_convertXyzToCieLab: function (color) {\n\t\tvar result = {}, c1, c2, c3;\n\n\t\tfunction f (t) {\n\t\t\treturn (t > 0.00885645167904) ? Math.pow(t, 1 / 3) : 70.08333333333263 * t + 0.13793103448276;\n\t\t}\n\n\t\tc1 = f(color.c1 / this._refWhite.c1);\n\t\tc2 = f(color.c2 / this._refWhite.c2);\n\t\tc3 = f(color.c3 / this._refWhite.c3);\n\n\t\tresult.c1 = (116 * c2) - 16;\n\t\tresult.c2 = 500 * (c1 - c2);\n\t\tresult.c3 = 200 * (c2 - c3);\n\t\tresult.c4 = color.c4;\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Calculates the lower limit\n\t *\n\t * @method _calculateLowerLimit\n\t * @param {int} value\n\t * @param {int} min\n\t * @param {int} shift\n\t * @return {int}\n\t * @private\n\t */\n\t_calculateLowerLimit: function (value, min, shift) {\n\t\treturn (value - shift) < min ? -(shift + (value - shift)) : -shift;\n\t},\n\n\t/**\n\t * Calculates the upper limit\n\t *\n\t * @method _calculateUpperLimit\n\t * @param {int} value\n\t * @param {int} max\n\t * @param {int} shift\n\t * @return {int}\n\t * @private\n\t */\n\t_calculateUpperLimit: function (value, max, shift) {\n\t\treturn (value + shift) > max ? (max - value) : shift;\n\t},\n\n\t/**\n\t * Checks if any pixel in the shift surrounding has a comparable color\n\t *\n\t * @method _shiftCompare\n\t * @param {int} x\n\t * @param {int} y\n\t * @param {object} color\n\t * @param {number} deltaThreshold\n\t * @param {PNGImage} imageA\n\t * @param {PNGImage} imageB\n\t * @param {int} width\n\t * @param {int} height\n\t * @param {int} hShift\n\t * @param {int} vShift\n\t * @param {boolean} [perceptual=false]\n\t * @param {object} [gamma]\n\t * @return {boolean} Is pixel within delta found in surrounding?\n\t * @private\n\t */\n\t_shiftCompare: function (x, y, color, deltaThreshold, imageA, imageB, width, height, hShift, vShift, perceptual, gamma) {\n\n\t\tvar i, xOffset, xLow, xHigh, yOffset, yLow, yHigh, delta, color1, color2, localDeltaThreshold;\n\n\t\tif ((hShift > 0) || (vShift > 0)) {\n\n\t\t\txLow = this._calculateLowerLimit(x, 0, hShift);\n\t\t\txHigh = this._calculateUpperLimit(x, width - 1, hShift);\n\n\t\t\tyLow = this._calculateLowerLimit(y, 0, vShift);\n\t\t\tyHigh = this._calculateUpperLimit(y, height - 1, vShift);\n\n\t\t\tfor (xOffset = xLow; xOffset <= xHigh; xOffset++) {\n\t\t\t\tfor (yOffset = yLow; yOffset <= yHigh; yOffset++) {\n\n\t\t\t\t\tif ((xOffset != 0) || (yOffset != 0)) {\n\n\t\t\t\t\t\ti = imageB.getIndex(x + xOffset, y + yOffset);\n\n\t\t\t\t\t\tcolor1 = this._getColor(imageA, i, perceptual, gamma);\n\t\t\t\t\t\tlocalDeltaThreshold = this._colorDelta(color, color1);\n\n\t\t\t\t\t\tcolor2 = this._getColor(imageB, i, perceptual, gamma);\n\t\t\t\t\t\tdelta = this._colorDelta(color, color2);\n\n\t\t\t\t\t\tif ((Math.abs(delta - localDeltaThreshold) < deltaThreshold) && (localDeltaThreshold > deltaThreshold)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t * Does a quick comparison between the supplied images\n\t *\n\t * @method _pixelCompare\n\t * @param {PNGImage} imageA\n\t * @param {PNGImage} imageB\n\t * @param {PNGImage} imageOutput\n\t * @param {number} deltaThreshold\n\t * @param {int} width Width of image\n\t * @param {int} height Height of image\n\t * @param {object} outputMaskColor\n\t * @param {int} [outputMaskColor.red]\n\t * @param {int} [outputMaskColor.green]\n\t * @param {int} [outputMaskColor.blue]\n\t * @param {int} [outputMaskColor.alpha]\n\t * @param {float} [outputMaskColor.opacity]\n\t * @param {object} outputShiftColor\n\t * @param {int} [outputShiftColor.red]\n\t * @param {int} [outputShiftColor.green]\n\t * @param {int} [outputShiftColor.blue]\n\t * @param {int} [outputShiftColor.alpha]\n\t * @param {float} [outputShiftColor.opacity]\n\t * @param {object} backgroundColor\n\t * @param {int} [backgroundColor.red]\n\t * @param {int} [backgroundColor.green]\n\t * @param {int} [backgroundColor.blue]\n\t * @param {int} [backgroundColor.alpha]\n\t * @param {float} [backgroundColor.opacity]\n\t * @param {int} [hShift=0] Horizontal shift\n\t * @param {int} [vShift=0] Vertical shift\n\t * @param {boolean} [perceptual=false]\n\t * @param {object} [gamma]\n\t * @return {int} Number of pixel differences\n\t * @private\n\t */\n\t_pixelCompare: function (imageA, imageB, imageOutput, deltaThreshold, width, height, outputMaskColor, outputShiftColor, backgroundColor, hShift, vShift, perceptual, gamma) {\n\t\tvar difference = 0, i, x, y, delta, color1, color2;\n\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\ti = imageA.getIndex(x, y);\n\n\t\t\t\tcolor1 = this._getColor(imageA, i, perceptual, gamma);\n\t\t\t\tcolor2 = this._getColor(imageB, i, perceptual, gamma);\n\n\t\t\t\tdelta = this._colorDelta(color1, color2);\n\n\t\t\t\tif (delta > deltaThreshold) {\n\n\t\t\t\t\tif (this._shiftCompare(x, y, color1, deltaThreshold, imageA, imageB, width, height, hShift, vShift, perceptual, gamma) && this._shiftCompare(x, y, color2, deltaThreshold, imageB, imageA, width, height, hShift, vShift, perceptual, gamma)) {\n\t\t\t\t\t\timageOutput.setAtIndex(i, outputShiftColor);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdifference++;\n\t\t\t\t\t\timageOutput.setAtIndex(i, outputMaskColor);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\timageOutput.setAtIndex(i, backgroundColor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn difference;\n\t},\n\n\t/**\n\t * Compares the two images supplied\n\t *\n\t * @method _compare\n\t * @param {PNGImage} imageA\n\t * @param {PNGImage} imageB\n\t * @param {PNGImage} imageOutput\n\t * @param {number} deltaThreshold\n\t * @param {object} outputMaskColor\n\t * @param {int} [outputMaskColor.red]\n\t * @param {int} [outputMaskColor.green]\n\t * @param {int} [outputMaskColor.blue]\n\t * @param {int} [outputMaskColor.alpha]\n\t * @param {float} [outputMaskColor.opacity]\n\t * @param {object} outputShiftColor\n\t * @param {int} [outputShiftColor.red]\n\t * @param {int} [outputShiftColor.green]\n\t * @param {int} [outputShiftColor.blue]\n\t * @param {int} [outputShiftColor.alpha]\n\t * @param {float} [outputShiftColor.opacity]\n\t * @param {object} backgroundColor\n\t * @param {int} [backgroundColor.red]\n\t * @param {int} [backgroundColor.green]\n\t * @param {int} [backgroundColor.blue]\n\t * @param {int} [backgroundColor.alpha]\n\t * @param {float} [backgroundColor.opacity]\n\t * @param {int} [hShift=0] Horizontal shift\n\t * @param {int} [vShift=0] Vertical shift\n\t * @param {boolean} [perceptual=false]\n\t * @param {object} [gamma]\n\t * @return {object}\n\t * @private\n\t */\n\t_compare: function (imageA, imageB, imageOutput, deltaThreshold, outputMaskColor, outputShiftColor, backgroundColor, hShift, vShift, perceptual, gamma) {\n\n\t\tvar result = {\n\t\t\tcode: BlinkDiff.RESULT_UNKNOWN,\n\t\t\tdifferences: undefined,\n\t\t\tdimension: undefined,\n\t\t\twidth: undefined,\n\t\t\theight: undefined\n\t\t};\n\n\t\t// Get some data needed for comparison\n\t\tresult.width = imageA.getWidth();\n\t\tresult.height = imageA.getHeight();\n\t\tresult.dimension = result.width * result.height;\n\n\t\t// Check if identical\n\t\tresult.differences = this._pixelCompare(imageA, imageB, imageOutput, deltaThreshold, result.width, result.height, outputMaskColor, outputShiftColor, backgroundColor, hShift, vShift, perceptual, gamma);\n\n\t\t// Result\n\t\tif (result.differences == 0) {\n\t\t\tthis.log(\"Images are identical or near identical\");\n\t\t\tresult.code = BlinkDiff.RESULT_IDENTICAL;\n\t\t\treturn result;\n\n\t\t} else if (this.isAboveThreshold(result.differences, result.dimension)) {\n\t\t\tthis.log(\"Images are visibly different\");\n\t\t\tthis.log(result.differences + \" pixels are different\");\n\t\t\tresult.code = BlinkDiff.RESULT_DIFFERENT;\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tthis.log(\"Images are similar\");\n\t\t\tthis.log(result.differences + \" pixels are different\");\n\t\t\tresult.code = BlinkDiff.RESULT_SIMILAR;\n\t\t\treturn result;\n\t\t}\n\t}\n};\n\nmodule.exports = BlinkDiff;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/index2.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar PNGImage = require('pngjs-image'),\n\tConfig = require('./lib/configuration/config'),\n\tImage = require('./lib/image'),\n\tPixelComparator = require('./lib/pixelComparator'),\n\tconstants = require('./lib/constants'),\n\tBase = require('preceptor-core').Base;\n\n/**\n * @class BlinkDiff\n * @extends Base\n * @module Compare\n *\n * @property {Config} _configuration\n * @property {PNGImage} _outputImage\n * @property {PNGImage} _highlightImage\n */\nvar BlinkDiff = Base.extend(\n\n\t/**\n\t * Constructor\n\t *\n\t * @constructor\n\t * @param {object} options\n\t */\n\tfunction (options) {\n\t\toptions = options || {};\n\t\toptions.blinkDiff = this;\n\t\tthis._configuration = new Config(options);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the configuration\n\t\t *\n\t\t * @method getConfig\n\t\t * @return {Config}\n\t\t */\n\t\tgetConfig: function () {\n\t\t\treturn this._configuration;\n\t\t},\n\n\t\t/**\n\t\t * Gets the output image\n\t\t *\n\t\t * @method getOutputImage\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetOutputImage: function () {\n\t\t\treturn this._outputImage;\n\t\t},\n\n\t\t/**\n\t\t * Gets the highlight image\n\t\t *\n\t\t * @method getHighlightImage\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetHighlightImage: function () {\n\t\t\treturn this._highlightImage;\n\t\t},\n\n\n\t\t/**\n\t\t * Logs events to the console\n\t\t *\n\t\t * @method log\n\t\t * @param {string} text\n\t\t */\n\t\tlog: function (text) {\n\t\t\tif (this._configuration.isVerboseMode()) {\n\t\t\t\tconsole.log(text);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Clips the images to the lower resolution of both, if needed\n\t\t *\n\t\t * @private\n\t\t * @method _clip\n\t\t * @param {PNGImage} imageA Source image\n\t\t * @param {PNGImage} imageB Destination image\n\t\t */\n\t\t_clip: function (imageA, imageB) {\n\n\t\t\tvar minWidth, minHeight;\n\n\t\t\tif ((imageA.getWidth() != imageB.getWidth()) || (imageA.getHeight() != imageB.getHeight())) {\n\n\t\t\t\tminWidth = Math.min(imageA.getWidth(), imageB.getWidth());\n\t\t\t\tminHeight = Math.min(imageA.getHeight(), imageB.getHeight());\n\n\t\t\t\tthis.log(\"Clipping to \" + minWidth + \" x \" + minHeight);\n\n\t\t\t\timageA.clip(0, 0, minWidth, minHeight);\n\t\t\t\timageB.clip(0, 0, minWidth, minHeight);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Has comparison passed?\n\t\t *\n\t\t * @method hasPassed\n\t\t * @param {int} result Comparison result-code\n\t\t * @return {boolean}\n\t\t */\n\t\thasPassed: function (result) {\n\t\t\treturn ((result !== constants.RESULT_DIFFERENT) && (result !== constants.RESULT_UNKNOWN));\n\t\t},\n\n\t\t/**\n\t\t * Runs the comparison synchronously\n\t\t *\n\t\t * @method process\n\t\t * @return {Object} Result of comparison { code, differences, dimension, width, height }\n\t\t */\n\t\tprocess: function () {\n\n\t\t\t// Catch all image errors\n\t\t\tPNGImage.log = function (text) {\n\t\t\t\tthis.log('ERROR: ' + text);\n\t\t\t\tthrow new Error('ERROR: ' + text);\n\t\t\t}.bind(this);\n\n\t\t\tvar config = this.getConfig(),\n\n\t\t\t\tdimension,\n\t\t\t\tflagField,\n\t\t\t\timageA = config.getImageA().getProcessedImage(),\n\t\t\t\timageB = config.getImageB().getProcessedImage(),\n\t\t\t\tcompareImageA, compareImageB,\n\n\t\t\t\thighlightImage,\n\t\t\t\toutputImage,\n\t\t\t\tdifferences = 0,\n\t\t\t\tshifts = 0,\n\t\t\t\ti, index, color,\n\t\t\t\texported = false,\n\t\t\t\tcode = constants.RESULT_UNKNOWN;\n\n\t\t\tthis._highlightImage = null;\n\t\t\tthis._outputImage = null;\n\n\t\t\tthis._clip(imageA, imageB);\n\n\t\t\tdimension = imageA.getWidth() * imageB.getWidth();\n\t\t\tflagField = new Buffer(dimension);\n\t\t\tflagField.fill(0);\n\n\t\t\tconfig.getComparisons().forEach(function (comparison, index) {\n\n\t\t\t\tthis.log('Apply comparison #' + index);\n\n\t\t\t\tcompareImageA = Image.processImage(PNGImage.copyImage(imageA), comparison);\n\t\t\t\tcompareImageB = Image.processImage(PNGImage.copyImage(imageB), comparison);\n\n\t\t\t\tvar pixelCompare = new PixelComparator(compareImageA, compareImageB, config);\n\t\t\t\tpixelCompare.compare(comparison, flagField);\n\n\t\t\t}.bind(this));\n\n\t\t\tif (config.isDebugMode()) { // In debug-mode? Export comparison image\n\n\t\t\t\tthis.log('In debug-mode');\n\n\t\t\t\timageA = compareImageA || imageA;\n\t\t\t\timageB = compareImageB || imageB;\n\t\t\t}\n\n\t\t\thighlightImage = PNGImage.createImage(imageA.getWidth(), imageA.getHeight());\n\n\t\t\toutputImage = PNGImage.createImage(imageA.getWidth(), imageA.getHeight());\n\t\t\tconfig.getOutput().copyImage(imageA, imageB, outputImage);\n\n\t\t\t// Draw and count flag-field\n\t\t\tfor(i = 0; i < dimension; i++) {\n\n\t\t\t\tindex = i * 4;\n\n\t\t\t\t// Count\n\t\t\t\tif (flagField[i] & 1 == 1) {\n\t\t\t\t\tdifferences++;\n\t\t\t\t}\n\t\t\t\tif (flagField[i] & 2 == 2) {\n\t\t\t\t\tshifts++;\n\t\t\t\t}\n\n\t\t\t\t// Draw\n\t\t\t\tif (flagField[i] & 1 == 1) {\n\t\t\t\t\tcolor = config.getDiffColor();\n\n\t\t\t\t} else if (flagField[i] & 2 == 2) {\n\t\t\t\t\tcolor = config.getIgnoreColor();\n\n\t\t\t\t} else {\n\t\t\t\t\tcolor = config.getBackgroundColor();\n\t\t\t\t}\n\n\t\t\t\toutputImage.setAtIndex(index, color.getColor(true, true));\n\t\t\t\thighlightImage.setAtIndex(index, color.getColor(false, false));\n\t\t\t}\n\n\t\t\t// Create composition if requested\n\t\t\tthis._highlightImage = highlightImage;\n\t\t\tthis._outputImage = config.getOutput().createComposition(imageA, imageB, outputImage);\n\n\t\t\t// Result\n\t\t\tif (differences == 0) {\n\t\t\t\tthis.log(\"Images are identical or near identical\");\n\t\t\t\tcode = constants.RESULT_IDENTICAL;\n\n\t\t\t} else if (config.getThreshold().isAboveThreshold(differences, dimension)) {\n\t\t\t\tthis.log(\"Images are visibly different\");\n\t\t\t\tthis.log(differences + \" pixels are different\");\n\t\t\t\tcode = constants.RESULT_DIFFERENT;\n\n\t\t\t} else {\n\t\t\t\tthis.log(\"Images are similar\");\n\t\t\t\tthis.log(differences + \" pixels are different\");\n\t\t\t\tcode = constants.RESULT_SIMILAR;\n\t\t\t}\n\n\t\t\t// Need to write to the filesystem?\n\t\t\tif (config.getOutput().withinOutputLimit(code)) {\n\t\t\t\tif (config.getOutput().writeImage(this._outputImage)) {\n\t\t\t\t\tthis.log(\"Wrote differences to \" + config.getOutput().getImagePath());\n\t\t\t\t\texported = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcode: code,\n\t\t\t\tdifferences: differences,\n\t\t\t\tshifts: shifts,\n\t\t\t\tdimension: dimension,\n\t\t\t\twidth: imageA.getWidth(),\n\t\t\t\theight: imageA.getWidth(),\n\t\t\t\thighlightImage: highlightImage,\n\t\t\t\toutputImage: outputImage,\n\t\t\t\texported: exported\n\t\t\t};\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * Version\n\t\t *\n\t\t * @static\n\t\t * @property version\n\t\t * @type {string}\n\t\t */\n\t\tversion: require('./package.json').version\n\t}\n);\n\nmodule.exports = BlinkDiff;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/config.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar Image = require('./image');\nvar PixelComparison = require('./pixelComparison');\nvar StructureComparison = require('./structureComparison');\nvar Threshold = require('./atoms/threshold');\nvar Color = require('./atoms/color');\nvar Output = require('./output');\n\nvar constants = require('../constants');\n\n/**\n * @class Config\n * @extends Base\n * @module Configuration\n *\n * @property {boolean} debug\n * @property {boolean} verbose\n * @property {Image} _imageA\n * @property {Image} _imageB\n * @property {PixelComparison[]|StructureComparison[]} _comparisons\n * @property {Threshold} _threshold\n * @property {Color} _diffColor\n * @property {Color} _backgroundColor\n * @property {Color} _ignoreColor\n * @property {Output} _output\n */\nvar Config = Base.extend(\n\n\t/**\n\t * Config constructor\n\t *\n\t * @param {object} options\n\t * @param {boolean} options.debug\n\t * @param {boolean} options.verbose\n\t * @param {object|Image} options.imageA\n\t * @param {object|Image} options.imageB\n\t * @param {object[]|PixelComparison[]|StructureComparison[]} options.comparisons\n\t * @param {object|Threshold} options.threshold\n\t * @param {object|Color} options.diffColor\n\t * @param {object|Color} options.backgroundColor\n\t * @param {object|Color} options.ignoreColor\n\t * @param {object|Output} options.output\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\tdebug: false,\n\t\t\tverbose: false,\n\n\t\t\timageA: {},\n\t\t\timageB: {},\n\n\t\t\tcomparisons: [],\n\n\t\t\tthreshold: {},\n\n\t\t\tdiffColor: {},\n\t\t\tbackgroundColor: {},\n\t\t\tignoreColor: {},\n\n\t\t\toutput: {}\n\t\t}, [options]);\n\n\t\tthis.setDebugMode(options.debug);\n\t\tthis.setVerboseMode(options.verbose);\n\n\t\tthis.setImageA(options.imageA);\n\t\tthis.setImageB(options.imageB);\n\n\t\tthis.setComparisons(options.comparisons);\n\n\t\tthis.setThreshold(options.threshold);\n\n\t\tthis.setDiffColor(options.diffColor);\n\t\tthis.setBackgroundColor(options.backgroundColor);\n\t\tthis.setIgnoreColor(options.ignoreColor);\n\n\t\tthis.setOutput(options.output);\n\t},\n\n\t{\n\t\t/**\n\t\t * Is in debug-mode?\n\t\t *\n\t\t * @method isDebugMode\n\t\t * @return {boolean}\n\t\t */\n\t\tisDebugMode: function () {\n\t\t\treturn this._debug;\n\t\t},\n\n\t\t/**\n\t\t * Sets the debug-mode\n\t\t *\n\t\t * @method setDebugMode\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetDebugMode: function (value) {\n\t\t\tthis._debug = !!value;\n\t\t},\n\n\n\t\t/**\n\t\t * Is in verbose-mode?\n\t\t *\n\t\t * @method isVerboseMode\n\t\t * @return {boolean}\n\t\t */\n\t\tisVerboseMode: function () {\n\t\t\treturn this._verbose;\n\t\t},\n\n\t\t/**\n\t\t * Sets the verbose-mode\n\t\t *\n\t\t * @method setVerboseMode\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetVerboseMode: function (value) {\n\t\t\tthis._verbose = !!value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the first image\n\t\t *\n\t\t * @method getImageA\n\t\t * @return {Image}\n\t\t */\n\t\tgetImageA: function () {\n\t\t\treturn this._imageA;\n\t\t},\n\n\t\t/**\n\t\t * Sets the first image\n\t\t *\n\t\t * @method setImageA\n\t\t * @param {object|Image} value\n\t\t */\n\t\tsetImageA: function (value) {\n\t\t\tthis._imageA = this._parseObject(value, Image, 'image A');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the second image\n\t\t *\n\t\t * @method getImageB\n\t\t * @return {Image}\n\t\t */\n\t\tgetImageB: function () {\n\t\t\treturn this._imageB;\n\t\t},\n\n\t\t/**\n\t\t * Sets the second image\n\t\t *\n\t\t * @method setImageB\n\t\t * @param {object|Image} value\n\t\t */\n\t\tsetImageB: function (value) {\n\t\t\tthis._imageB = this._parseObject(value, Image, 'image B');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the comparisons\n\t\t *\n\t\t * @method getComparisons\n\t\t * @return {PixelComparison[]|StructureComparison[]}\n\t\t */\n\t\tgetComparisons: function () {\n\t\t\treturn this._comparisons;\n\t\t},\n\n\t\t/**\n\t\t * Sets the comparisons\n\t\t *\n\t\t * @method setComparisons\n\t\t * @param {object[]|PixelComparison[]|StructureComparison[]} value\n\t\t */\n\t\tsetComparisons: function (value) {\n\n\t\t\tvar list = [];\n\n\t\t\tvalue.forEach(function (comparison) {\n\t\t\t\tlist.push(this._parseComparison(comparison));\n\t\t\t}.bind(this));\n\n\t\t\tthis._comparisons = list;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the threshold\n\t\t *\n\t\t * @method getThreshold\n\t\t * @return {Threshold}\n\t\t */\n\t\tgetThreshold: function () {\n\t\t\treturn this._threshold;\n\t\t},\n\n\t\t/**\n\t\t * Sets the threshold\n\t\t *\n\t\t * @method setThreshold\n\t\t * @param {object|Threshold} value\n\t\t */\n\t\tsetThreshold: function (value) {\n\t\t\tthis._threshold = this._parseObject(value, Threshold, 'threshold');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the diff-color\n\t\t *\n\t\t * @method getDiffColor\n\t\t * @return {Color}\n\t\t */\n\t\tgetDiffColor: function () {\n\t\t\treturn this._diffColor;\n\t\t},\n\n\t\t/**\n\t\t * Sets the diff-color\n\t\t *\n\t\t * @method setDiffColor\n\t\t * @param {object|Color} value\n\t\t */\n\t\tsetDiffColor: function (value) {\n\t\t\tthis._diffColor = this._parseObject(value, Color, 'color');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the background-color\n\t\t *\n\t\t * @method getBackgroundColor\n\t\t * @return {Color}\n\t\t */\n\t\tgetBackgroundColor: function () {\n\t\t\treturn this._backgroundColor;\n\t\t},\n\n\t\t/**\n\t\t * Sets the background-color\n\t\t *\n\t\t * @method setBackgroundColor\n\t\t * @param {object|Color} value\n\t\t */\n\t\tsetBackgroundColor: function (value) {\n\t\t\tthis._backgroundColor = this._parseObject(value, Color, 'color');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the ignore-color\n\t\t *\n\t\t * @method getIgnoreColor\n\t\t * @return {Color}\n\t\t */\n\t\tgetIgnoreColor: function () {\n\t\t\treturn this._ignoreColor;\n\t\t},\n\n\t\t/**\n\t\t * Sets the ignore-color\n\t\t *\n\t\t * @method setIgnoreColor\n\t\t * @param {object|Color} value\n\t\t */\n\t\tsetIgnoreColor: function (value) {\n\t\t\tthis._ignoreColor = this._parseObject(value, Color, 'color');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the output\n\t\t *\n\t\t * @method getOutput\n\t\t * @return {Output}\n\t\t */\n\t\tgetOutput: function () {\n\t\t\treturn this._output;\n\t\t},\n\n\t\t/**\n\t\t * Sets the output\n\t\t *\n\t\t * @method setOutput\n\t\t * @param {object|Output} value\n\t\t */\n\t\tsetOutput: function (value) {\n\t\t\tthis._output = this._parseObject(value, Output, 'output');\n\t\t},\n\n\n\t\t/**\n\t\t * Parses comparison information\n\t\t *\n\t\t * @method _parseComparison\n\t\t * @param {object|PixelComparison|StructureComparison} value Comparison or comparison-description\n\t\t * @returns {PixelComparison|StructureComparison}\n\t\t * @private\n\t\t */\n\t\t_parseComparison: function (value) {\n\n\t\t\tvar Constr = null,\n\t\t\t\ttext = \"comparison\";\n\n\t\t\tif (value.type === constants.COMPARISON_PIXEL) {\n\t\t\t\tConstr = PixelComparison;\n\t\t\t\ttext = 'pixel-comparison';\n\n\t\t\t} else if (value.type === constants.COMPARISON_STRUCTURE) {\n\t\t\t\tConstr = StructureComparison;\n\t\t\t\ttext = 'structural-comparison'\n\t\t\t}\n\n\t\t\treturn this._parseObject(value, Constr, text);\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_CONFIG'\n\t}\n);\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/base.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar CoreBase = require('preceptor-core').Base;\n\n/**\n * @class Base\n * @extends CoreBase\n * @module Configuration\n */\nvar Base = CoreBase.extend(\n\n\t/**\n\t * Base constructor\n\t *\n\t * @constructor\n\t * @param {object} options\n\t */\n\tfunction (options) {\n\t\tthis._blinkDiff = options.blinkDiff;\n\t},\n\n\t{\n\t\t/**\n\t\t * Logs events to the blink-diff instance\n\t\t *\n\t\t * @method log\n\t\t * @param {string} text\n\t\t */\n\t\tlog: function (text) {\n\t\t\tif (this._blinkDiff) {\n\t\t\t\tthis._blinkDiff.log(this.constructor.TYPE + ': ' + text);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Parses object information\n\t\t *\n\t\t * @method _parseObject\n\t\t * @param {object|Image} value\n\t\t * @param {object} Constr Constructor of data-type\n\t\t * @param {string} typeStr Textual type description of object\n\t\t * @return {object}\n\t\t * @private\n\t\t */\n\t\t_parseObject: function (value, Constr, typeStr) {\n\n\t\t\tif (typeof value == 'object' && !(value instanceof Constr)) {\n\t\t\t\tvalue.blinkDiff = this._blinkDiff;\n\t\t\t\tvalue = new Constr(value);\n\t\t\t}\n\n\t\t\tif (value instanceof Constr) {\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown ' + typeStr + ' descriptor.');\n\t\t\t}\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_BASE'\n\t}\n);\n\nmodule.exports = Base;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/image.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar fs = require('fs');\n\nvar Base = require('./base');\nvar PNGImage = require('pngjs-image');\nvar utils = require('preceptor-core').utils;\n\nvar Rect = require('./atoms/rect');\nvar Structure = require('./structure/structure');\n\n/**\n * @class Image\n * @extends Base\n * @module Configuration\n *\n * @property {PNGImage} _image\n * @property {Structure} _structure\n * @property {Rect} _crop\n *\n * @property {boolean} _alreadyCropped\n * @property {PNGImage} _croppedImage\n */\nvar Image = Base.extend(\n\n\t/**\n\t * Image constructor\n\t *\n\t * @param {object} options\n\t * @param {string|PNGImage} options.image Image\n\t * @param {object|Structure} options.structure Structure of the image as a DOM\n\t * @param {object|Rect} [options.crop] Cropping of the image\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\tstructure: null,\n\t\t\timage: null,\n\t\t\tcrop: {}\n\t\t}, [options]);\n\n\t\tif (options.structure) {\n\t\t\tthis.setStructure(options.structure);\n\t\t}\n\t\tthis.setImage(options.image);\n\n\t\tthis.setCropRect(options.crop);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the image\n\t\t *\n\t\t * @method getImage\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetImage: function () {\n\t\t\treturn this._image;\n\t\t},\n\n\t\t/**\n\t\t * Sets the image\n\t\t *\n\t\t * @method setImage\n\t\t * @param {string|PNGImage} image\n\t\t */\n\t\tsetImage: function (image) {\n\n\t\t\tif (typeof image == 'string') {\n\t\t\t\timage = this._readImage(image);\n\n\t\t\t} else if (typeof image == 'buffer') {\n\t\t\t\timage = this._loadImage(image);\n\t\t\t}\n\n\t\t\tif (image instanceof PNGImage) {\n\t\t\t\tthis._image = image;\n\t\t\t\tthis._alreadyCropped = false;\n\t\t\t\tthis._croppedImage = null;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown image format.');\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Reads the image from the FS\n\t\t *\n\t\t * @param {string} path\n\t\t * @return {PNGImage}\n\t\t * @private\n\t\t */\n\t\t_readImage: function (path) {\n\t\t\tthis.log('Read image: ' + path);\n\t\t\treturn this._loadImage(fs.readFileSync(path));\n\t\t},\n\n\t\t/**\n\t\t * Loads the image from a buffer\n\t\t *\n\t\t * @param {Buffer} blob\n\t\t * @return {PNGImage}\n\t\t * @private\n\t\t */\n\t\t_loadImage: function (blob) {\n\n\t\t\tvar decoder,\n\t\t\t\tdata,\n\t\t\t\theaderChunk,\n\t\t\t\tstructureChunk,\n\t\t\t\twidth, height,\n\t\t\t\timage,\n\t\t\t\tDecoder = PNGImage.Decoder;\n\n\t\t\tthis.log('Load image');\n\t\t\tdecoder = new Decoder();\n\t\t\tdata = decoder.decode(blob, { strict: false });\n\n\t\t\theaderChunk = decoder.getHeaderChunk();\n\t\t\twidth = headerChunk.getWidth();\n\t\t\theight = headerChunk.getHeight();\n\n\t\t\t// Load structure when embedded\n\t\t\tif (decoder.hasChunksOfType('stRT')) {\n\t\t\t\tstructureChunk = decoder.getFirstChunk('stRT');\n\n\t\t\t\tif ((structureChunk.getDataType() == 'BLDF') &&\n\t\t\t\t\t(structureChunk.getMajor() == 1) &&\n\t\t\t\t\t(structureChunk.getMinor() == 0) &&\n\t\t\t\t\tstructureChunk.getContent())\n\t\t\t\t{\n\t\t\t\t\tthis.log('Found structural data');\n\t\t\t\t\tthis.setStructure(structureChunk.getContent());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timage = new PNG({\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t\tdata.copy(image.data, 0, 0, data.length);\n\n\t\t\treturn new PNGImage(image);\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the structure of the image as a DOM\n\t\t *\n\t\t * @method getStructure\n\t\t * @return {Structure}\n\t\t */\n\t\tgetStructure: function () {\n\t\t\treturn this._structure;\n\t\t},\n\n\t\t/**\n\t\t * Sets the structure of the image as a DOM\n\t\t *\n\t\t * @method setStructure\n\t\t * @return {object|Structure}\n\t\t */\n\t\tsetStructure: function (value) {\n\t\t\tthis._structure = this._parseObject(value, Structure, 'structure');\n\t\t},\n\n\n\t\t/**\n\t\t * Is image cropped?\n\t\t *\n\t\t * @method isCropped\n\t\t * @return {boolean}\n\t\t */\n\t\tisCropped: function () {\n\t\t\treturn !!this._crop;\n\t\t},\n\n\t\t/**\n\t\t * Gets the cropping rectangle\n\t\t *\n\t\t * @method getCropRect\n\t\t * @return {Rect}\n\t\t */\n\t\tgetCropRect: function () {\n\t\t\treturn this._crop;\n\t\t},\n\n\t\t/**\n\t\t * Sets the cropping rectangle\n\t\t *\n\t\t * @method setCropRect\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetCropRect: function (value) {\n\t\t\tthis._crop = this._parseObject(value, Rect, 'rect');\n\t\t\tthis._alreadyCropped = false;\n\t\t\tthis._croppedImage = null;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the processed image\n\t\t *\n\t\t * @method getProcessedImage\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetProcessedImage: function () {\n\n\t\t\tvar rect, coord;\n\n\t\t\tif (!this.isCropped()) {\n\t\t\t\treturn PNGImage.copyImage(this.getImage());\n\t\t\t}\n\n\t\t\tif (!this._alreadyCropped) {\n\n\t\t\t\tthis.log('Cropping image');\n\t\t\t\trect = this.getCropRect().clone();\n\t\t\t\trect.limitCoordinates({\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth: this.getImage().getWidth(),\n\t\t\t\t\theight: this.getImage().getHeight()\n\t\t\t\t});\n\n\t\t\t\tcoord = rect.getCoordinates();\n\n\t\t\t\tthis._croppedImage = PNGImage.copyImage(this.getImage());\n\t\t\t\tthis._croppedImage.clip(coord.x, coord.y, coord.width, coord.height);\n\n\t\t\t\tthis._alreadyCropped = true;\n\t\t\t}\n\n\t\t\treturn this._croppedImage;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_IMAGE'\n\t}\n);\n\nmodule.exports = Image;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/atoms/rect.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\nvar utils = require('preceptor-core').utils;\n\n/**\n * @class Rect\n * @extends Base\n * @module Configuration\n * @submodule Atoms\n *\n * @property {int} _left\n * @property {int} _top\n * @property {int} _width\n * @property {int} _height\n */\nvar Rect = Base.extend(\n\n\t/**\n\t * Rect constructor\n\t *\n\t * @param {object} options\n\t * @param {int} options.left Offset from the left corner\n\t * @param {int} options.top Offset from the top corner\n\t * @param {int} options.width Width\n\t * @param {int} options.height Height\n\t * @param {int} [options.x] Offset from the left corner\n\t * @param {int} [options.y] Offset from the top corner\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({}, [options]);\n\n\t\tthis.setLeft(options.left || options.x);\n\t\tthis.setTop(options.top || options.y);\n\t\tthis.setWidth(options.width);\n\t\tthis.setHeight(options.height);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the offset from the left corner\n\t\t *\n\t\t * @method getLeft\n\t\t * @return {int}\n\t\t */\n\t\tgetLeft: function () {\n\t\t\treturn this._left;\n\t\t},\n\n\t\t/**\n\t\t * Sets the offset from the left corner\n\t\t *\n\t\t * @method setLeft\n\t\t * @param {int} value\n\t\t */\n\t\tsetLeft: function (value) {\n\t\t\tthis._left = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the offset from the top corner\n\t\t *\n\t\t * @method getTop\n\t\t * @return {int}\n\t\t */\n\t\tgetTop: function () {\n\t\t\treturn this._top;\n\t\t},\n\n\t\t/**\n\t\t * Sets the offset from the top corner\n\t\t *\n\t\t * @method setTop\n\t\t * @param {int} value\n\t\t */\n\t\tsetTop: function (value) {\n\t\t\tthis._top = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the width\n\t\t *\n\t\t * @method getWidth\n\t\t * @return {int}\n\t\t */\n\t\tgetWidth: function () {\n\t\t\treturn this._width;\n\t\t},\n\n\t\t/**\n\t\t * Sets the width\n\t\t *\n\t\t * @method setWidth\n\t\t * @param {int} value\n\t\t */\n\t\tsetWidth: function (value) {\n\t\t\tthis._width = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the height\n\t\t *\n\t\t * @method getHeight\n\t\t * @return {int}\n\t\t */\n\t\tgetHeight: function () {\n\t\t\treturn this._height;\n\t\t},\n\n\t\t/**\n\t\t * Sets the height\n\t\t *\n\t\t * @method setHeight\n\t\t * @param {int} value\n\t\t */\n\t\tsetHeight: function (value) {\n\t\t\tthis._height = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets boundaries as rect structure\n\t\t *\n\t\t * @method getRect\n\t\t * @return {{left: (int), top: (int), width: (int), height: (int)}}\n\t\t */\n\t\tgetRect: function () {\n\t\t\treturn {\n\t\t\t\tleft: this.getLeft(),\n\t\t\t\ttop: this.getTop(),\n\t\t\t\twidth: this.getWidth(),\n\t\t\t\theight: this.getHeight()\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets boundaries as coordinate structure\n\t\t *\n\t\t * @method getCoordinates\n\t\t * @return {{x: (int), y: (int), width: (int), height: (int)}}\n\t\t */\n\t\tgetCoordinates: function () {\n\t\t\treturn {\n\t\t\t\tx: this.getLeft(),\n\t\t\t\ty: this.getTop(),\n\t\t\t\twidth: this.getWidth(),\n\t\t\t\theight: this.getHeight()\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Checks if a coordinate is within the bounds of the rect\n\t\t *\n\t\t * @method inBounds\n\t\t * @param {int} x X-coordinate\n\t\t * @param {int} y Y-coordinate\n\t\t */\n\t\tinBounds: function (x, y) {\n\t\t\tif ((x < this.getLeft()) || (x > this.getLeft() + this.getWidth())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ((y < this.getTop()) || (y > this.getTop() + this.getHeight())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Limits the rect coordinates to a specified rect\n\t\t *\n\t\t * Note:\n\t\t *  Priority is on the x/y coordinates, and not on the size since the size will then be removed anyways.\n\t\t *\n\t\t * @method limitCoordinates\n\t\t * @param {Rect} outerRect Outer rect\n\t\t * @return {Rect}\n\t\t */\n\t\tlimitCoordinates: function (outerRect) {\n\n\t\t\tvar outerRectCoord = outerRect.getRect();\n\n\t\t\t// Set values if none given\n\t\t\tthis._left = this._left || outerRectCoord.left;\n\t\t\tthis._top = this._top || outerRectCoord.top;\n\t\t\tthis._width = this._width || outerRectCoord.width;\n\t\t\tthis._height = this._height || outerRectCoord.height;\n\n\t\t\t// Check negative values\n\t\t\tthis._left = Math.max(0, this._left);\n\t\t\tthis._top = Math.max(0, this._top);\n\t\t\tthis._width = Math.max(1, this._width);\n\t\t\tthis._height = Math.max(1, this._height);\n\n\t\t\t// Check dimensions\n\t\t\tthis._left = Math.min(this._left, outerRectCoord.width - 1); // -1 to make sure that there is an image\n\t\t\tthis._top = Math.min(this._top, outerRectCoord.height - 1);\n\t\t\tthis._width = Math.min(this._width, outerRectCoord.width - this._left);\n\t\t\tthis._height = Math.min(this._height, outerRectCoord.height - this._top);\n\n\t\t\t// Make sure that the this is at least one pixel by one pixel\n\t\t\tthis._width = Math.max(1, this._width);\n\t\t\tthis._height = Math.max(1, this._height);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Clones the rect\n\t\t *\n\t\t * @method clone\n\t\t * @return {Rect}\n\t\t */\n\t\tclone: function () {\n\t\t\treturn new Rect({\n\t\t\t\tleft: this.getLeft(),\n\t\t\t\ttop: this.getTop(),\n\t\t\t\twidth: this.getWidth(),\n\t\t\t\theight: this.getHeight()\n\t\t\t});\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_ATOM_RECT'\n\t}\n);\n\nmodule.exports = Rect;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/structure.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\nvar Version = require('./version');\nvar Device = require('./device');\nvar Document = require('./document');\nvar ViewPort = require('./viewPort');\nvar Screenshot = require('./screenshot');\nvar DomElement = require('./domElement');\n\n/**\n * @class Structure\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {Version} _version\n * @property {Device} _device\n * @property {Document} _document\n * @property {ViewPort} _viewPort\n * @property {Screenshot} _screenshot\n * @property {DomElement} _dom\n */\nvar Structure = Base.extend(\n\n\t/**\n\t * Structure constructor\n\t *\n\t * @param {object} options\n\t * @param {object|Version} options.version\n\t * @param {object|Device} options.device\n\t * @param {object|Document} options.document\n\t * @param {object|ViewPort} options.viewPort\n\t * @param {object|Screenshot} options.screenshot\n\t * @param {object|DomElement} options.dom\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setVersion(options.version);\n\t\tthis.setDevice(options.device);\n\t\tthis.setDocument(options.document);\n\t\tthis.setViewPort(options.viewPort);\n\t\tthis.setScreenshot(options.screenshot);\n\t\tthis.setDom(options.dom);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the version of the structure format\n\t\t *\n\t\t * @method getVersion\n\t\t * @return {Version}\n\t\t */\n\t\tgetVersion: function () {\n\t\t\treturn this._version;\n\t\t},\n\n\t\t/**\n\t\t * Sets the version of the structure format\n\t\t *\n\t\t * @method setVersion\n\t\t * @param {object|Version} value\n\t\t */\n\t\tsetVersion: function (value) {\n\t\t\tthis._version = this._parseObject(value, Version, 'version');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the device from where the data was recorded\n\t\t *\n\t\t * @method getDevice\n\t\t * @return {Device}\n\t\t */\n\t\tgetDevice: function () {\n\t\t\treturn this._device;\n\t\t},\n\n\t\t/**\n\t\t * Sets the device from where the data was recorded\n\t\t *\n\t\t * @method setDevice\n\t\t * @param {object|Device} value\n\t\t */\n\t\tsetDevice: function (value) {\n\t\t\tthis._device = this._parseObject(value, Device, 'device');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the document\n\t\t *\n\t\t * @method getDocument\n\t\t * @return {Document}\n\t\t */\n\t\tgetDocument: function () {\n\t\t\treturn this._document;\n\t\t},\n\n\t\t/**\n\t\t * Sets the document\n\t\t *\n\t\t * @method setDocument\n\t\t * @param {object|Document} value\n\t\t */\n\t\tsetDocument: function (value) {\n\t\t\tthis._document = this._parseObject(value, Document, 'document');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the view-port\n\t\t *\n\t\t * @method getViewPort\n\t\t * @return {ViewPort}\n\t\t */\n\t\tgetViewPort: function () {\n\t\t\treturn this._viewPort;\n\t\t},\n\n\t\t/**\n\t\t * Sets the view-port\n\t\t *\n\t\t * @method setViewPort\n\t\t * @param {object|ViewPort} value\n\t\t */\n\t\tsetViewPort: function (value) {\n\t\t\tthis._viewPort = this._parseObject(value, ViewPort, 'view-port');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the screenshot information\n\t\t *\n\t\t * @method getScreenshot\n\t\t * @return {Screenshot}\n\t\t */\n\t\tgetScreenshot: function () {\n\t\t\treturn this._screenshot;\n\t\t},\n\n\t\t/**\n\t\t * Sets the screenshot information\n\t\t *\n\t\t * @method setScreenshot\n\t\t * @param {object|Screenshot} value\n\t\t */\n\t\tsetScreenshot: function (value) {\n\t\t\tthis._screenshot = this._parseObject(value, Screenshot, 'screenshot');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the DOM\n\t\t *\n\t\t * @method getDom\n\t\t * @return {DomElement}\n\t\t */\n\t\tgetDom: function () {\n\t\t\treturn this._dom;\n\t\t},\n\n\t\t/**\n\t\t * Sets the DOM\n\t\t *\n\t\t * @method setDom\n\t\t * @param {object|DomElement} value\n\t\t */\n\t\tsetDom: function (value) {\n\t\t\tthis._dom = this._parseObject(value, DomElement, 'DOM');\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE'\n\t}\n);\n\nmodule.exports = Structure;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/version.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\n/**\n * @class Version\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {int} _major\n * @property {int} _minor\n */\nvar Version = Base.extend(\n\n\t/**\n\t * Version constructor\n\t *\n\t * @param {object} options\n\t * @param {int} options.major\n\t * @param {int} options.minor\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setMajor(options.major);\n\t\tthis.setMinor(options.minor);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the major part of the version\n\t\t *\n\t\t * @method getMajor\n\t\t * @return {int}\n\t\t */\n\t\tgetMajor: function () {\n\t\t\treturn this._major;\n\t\t},\n\n\t\t/**\n\t\t * Sets the major part of the version\n\t\t *\n\t\t * @method setMajor\n\t\t * @param {int} value\n\t\t */\n\t\tsetMajor: function (value) {\n\t\t\tthis._major = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the minor part of the version\n\t\t *\n\t\t * @method getMinor\n\t\t * @return {int}\n\t\t */\n\t\tgetMinor: function () {\n\t\t\treturn this._minor;\n\t\t},\n\n\t\t/**\n\t\t * Sets the minor part of the version\n\t\t *\n\t\t * @method setMinor\n\t\t * @param {int} value\n\t\t */\n\t\tsetMinor: function (value) {\n\t\t\tthis._minor = value;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_VERSION'\n\t}\n);\n\nmodule.exports = Version;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/device.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\nvar Rect = require('../atoms/rect');\n\n/**\n * @class Device\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {boolean} _stitched\n * @property {Rect} _section\n */\nvar Device = Base.extend(\n\n\t/**\n\t * Device constructor\n\t *\n\t * @param {object} options\n\t * @param {boolean} options.stitched\n\t * @param {object|Rect} options.section\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setStitched(options.stitched);\n\t\tthis.setSection(options.section);\n\t},\n\n\t{\n\t\t/**\n\t\t * Is screenshot stitched?\n\t\t *\n\t\t * @method isStitched\n\t\t * @return {boolean}\n\t\t */\n\t\tisStitched: function () {\n\t\t\treturn this._stitched;\n\t\t},\n\n\t\t/**\n\t\t * Sets if the screenshot was stitched\n\t\t *\n\t\t * @method setStitched\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetStitched: function (value) {\n\t\t\tthis._stitched = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the section of the complete screenshot that is represented by the image-data\n\t\t *\n\t\t * @method getSection\n\t\t * @return {Rect}\n\t\t */\n\t\tgetSection: function () {\n\t\t\treturn this._section;\n\t\t},\n\n\t\t/**\n\t\t * Sets the section of the complete screenshot that is represented by the image-data\n\t\t *\n\t\t * @method setSection\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetSection: function (value) {\n\t\t\tthis._section = this._parseObject(value, Rect, 'rect');\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_DEVICE'\n\t}\n);\n\nmodule.exports = Device;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/document.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\nvar Size = require('./device/size');\n\n/**\n * @class document\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {string} _title\n * @property {string} _url\n * @property {string} _referrer\n * @property {Size} _size\n */\nvar Document = Base.extend(\n\n\t/**\n\t * Document constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.title\n\t * @param {string} options.url\n\t * @param {string} options.referrer\n\t * @param {object|Size} options.size\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setTitle(options.title);\n\t\tthis.setUrl(options.url);\n\t\tthis.setReferrer(options.referrer);\n\t\tthis.setSize(options.size);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the title of the document\n\t\t *\n\t\t * @method getTitle\n\t\t * @return {string}\n\t\t */\n\t\tgetTitle: function () {\n\t\t\treturn this._title;\n\t\t},\n\n\t\t/**\n\t\t * Sets the title of the document\n\t\t *\n\t\t * @method setTitle\n\t\t * @param {string} value\n\t\t */\n\t\tsetTitle: function (value) {\n\t\t\tthis._title = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the url of the document\n\t\t *\n\t\t * @method getUrl\n\t\t * @return {string}\n\t\t */\n\t\tgetUrl: function () {\n\t\t\treturn this._url;\n\t\t},\n\n\t\t/**\n\t\t * Sets the url of the document\n\t\t *\n\t\t * @method setUrl\n\t\t * @param {string} value\n\t\t */\n\t\tsetUrl: function (value) {\n\t\t\tthis._url = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the referrer of the document\n\t\t *\n\t\t * @method getReferrer\n\t\t * @return {string}\n\t\t */\n\t\tgetReferrer: function () {\n\t\t\treturn this._referrer;\n\t\t},\n\n\t\t/**\n\t\t * Sets the referrer of the document\n\t\t *\n\t\t * @method setReferrer\n\t\t * @param {string} value\n\t\t */\n\t\tsetReferrer: function (value) {\n\t\t\tthis._referrer = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the size of the document\n\t\t *\n\t\t * @method getSize\n\t\t * @return {Size}\n\t\t */\n\t\tgetSize: function () {\n\t\t\treturn this._size;\n\t\t},\n\n\t\t/**\n\t\t * Sets the size of the document\n\t\t *\n\t\t * @method setSize\n\t\t * @param {object|Size} value\n\t\t */\n\t\tsetSize: function (value) {\n\t\t\tthis._size = this._parseObject(value, Size, 'size');\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_DOCUMENT'\n\t}\n);\n\nmodule.exports = Document;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/device/size.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../../base');\n\n/**\n * @class Size\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {int} _width\n * @property {int} _height\n */\nvar Size = Base.extend(\n\n\t/**\n\t * Size constructor\n\t *\n\t * @param {object} options\n\t * @param {int} options.width\n\t * @param {int} options.height\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setWidth(options.width);\n\t\tthis.setHeight(options.height);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the width\n\t\t *\n\t\t * @method getWidth\n\t\t * @return {int}\n\t\t */\n\t\tgetWidth: function () {\n\t\t\treturn this._width;\n\t\t},\n\n\t\t/**\n\t\t * Sets the width\n\t\t *\n\t\t * @method setWidth\n\t\t * @param {int} value\n\t\t */\n\t\tsetWidth: function (value) {\n\t\t\tthis._width = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the height\n\t\t *\n\t\t * @method getHeight\n\t\t * @return {int}\n\t\t */\n\t\tgetHeight: function () {\n\t\t\treturn this._height;\n\t\t},\n\n\t\t/**\n\t\t * Sets the height\n\t\t *\n\t\t * @method setHeight\n\t\t * @param {int} value\n\t\t */\n\t\tsetHeight: function (value) {\n\t\t\tthis._height = value;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_DEVICE_SIZE'\n\t}\n);\n\nmodule.exports = Size;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/viewPort.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Rect = require('../atoms/rect');\n\n/**\n * @class ViewPort\n * @extends Rect\n * @module Configuration\n * @submodule Structure\n */\nvar ViewPort = Rect.extend(\n\n\t/**\n\t * View-port constructor\n\t *\n\t * @param {object} options\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\t},\n\n\t{\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_VIEWPORT'\n\t}\n);\n\nmodule.exports = ViewPort;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/screenshot.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\nvar Rect = require('../atoms/rect');\n\n/**\n * @class Screenshot\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {boolean} _stitched\n * @property {Rect} _section\n */\nvar Screenshot = Base.extend(\n\n\t/**\n\t * Screenshot constructor\n\t *\n\t * @param {object} options\n\t * @param {boolean} options.stitched\n\t * @param {object|Rect} options.section\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setStitched(options.stitched);\n\t\tthis.setSection(options.section);\n\t},\n\n\t{\n\t\t/**\n\t\t * Is screenshot stitched?\n\t\t *\n\t\t * @method isStitched\n\t\t * @return {boolean}\n\t\t */\n\t\tisStitched: function () {\n\t\t\treturn this._stitched;\n\t\t},\n\n\t\t/**\n\t\t * Sets if the screenshot was stitched\n\t\t *\n\t\t * @method setStitched\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetStitched: function (value) {\n\t\t\tthis._stitched = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the section of the complete screenshot that is represented by the image-data\n\t\t *\n\t\t * @method getSection\n\t\t * @return {Rect}\n\t\t */\n\t\tgetSection: function () {\n\t\t\treturn this._section;\n\t\t},\n\n\t\t/**\n\t\t * Sets the section of the complete screenshot that is represented by the image-data\n\t\t *\n\t\t * @method setSection\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetSection: function (value) {\n\t\t\tthis._section = value;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_SCREENSHOT'\n\t}\n);\n\nmodule.exports = Screenshot;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structure/domElement.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\n\nvar Rect = require('../atoms/rect');\n\n/**\n * @class DomElement\n * @extends Base\n * @module Configuration\n * @submodule Structure\n *\n * @property {string} _id\n * @property {DomElement} _parent\n * @property {string} _tagName\n * @property {string[]} _classes\n * @property {Rect} _rect\n * @property {DomElement[]} _nodes\n */\nvar DomElement = Base.extend(\n\n\t/**\n\t * Dom-Element constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.id\n\t * @param {DomElement} options.parent\n\t * @param {string} options.tagName\n\t * @param {string[]} options.classes\n\t * @param {object|Rect} options.rect\n\t * @param {object[]|DomElement[]} options.nodes\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\tthis.setId(options.id);\n\t\tthis.setTagName(options.tagName);\n\t\tthis.setClasses(options.classes);\n\t\tthis.setRect(options.rect);\n\t\tthis.setNodes(options.nodes);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the id of the dom-element\n\t\t *\n\t\t * @method getId\n\t\t * @return {string}\n\t\t */\n\t\tgetId: function () {\n\t\t\treturn this._id;\n\t\t},\n\n\t\t/**\n\t\t * Sets the id of the dom-element\n\t\t *\n\t\t * @method setId\n\t\t * @param {string} value\n\t\t */\n\t\tsetId: function (value) {\n\t\t\tthis._id = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the parent of this DOM-element\n\t\t *\n\t\t * @method getParent\n\t\t * @return {DomElement}\n\t\t */\n\t\tgetParent: function () {\n\t\t\treturn this._parent;\n\t\t},\n\n\t\t/**\n\t\t * Sets the parent of this DOM-element\n\t\t *\n\t\t * @method setParent\n\t\t * @param {DomElement} value\n\t\t */\n\t\tsetParent: function (value) {\n\t\t\tthis._parent = value;\n\t\t},\n\n\t\t/**\n\t\t * Does this DOM-element have a parent?\n\t\t *\n\t\t * @return {boolean}\n\t\t */\n\t\thasParent: function () {\n\t\t\treturn !!this.getParent();\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the tag-name of the dom-element\n\t\t *\n\t\t * @method getTagName\n\t\t * @return {string}\n\t\t */\n\t\tgetTagName: function () {\n\t\t\treturn this._tagName;\n\t\t},\n\n\t\t/**\n\t\t * Sets the tag-name of the dom-element\n\t\t *\n\t\t * @method setTagName\n\t\t * @param {string} value\n\t\t */\n\t\tsetTagName: function (value) {\n\t\t\tthis._tagName = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the classes of the dom-element\n\t\t *\n\t\t * @method getClasses\n\t\t * @return {string[]}\n\t\t */\n\t\tgetClasses: function () {\n\t\t\treturn this._classes;\n\t\t},\n\n\t\t/**\n\t\t * Sets the classes of the dom-element\n\t\t *\n\t\t * @method setClasses\n\t\t * @param {string[]} value\n\t\t */\n\t\tsetClasses: function (value) {\n\t\t\tthis._classes = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the position and dimension of the dom-element\n\t\t *\n\t\t * @method getRect\n\t\t * @return {Rect}\n\t\t */\n\t\tgetRect: function () {\n\t\t\treturn this._rect;\n\t\t},\n\n\t\t/**\n\t\t * Sets the position and dimension of the dom-element\n\t\t *\n\t\t * @method setRect\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetRect: function (value) {\n\t\t\tthis._rect = this._parseObject(value, Rect, 'rect');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the nodes of the dom-element\n\t\t *\n\t\t * @method getNodes\n\t\t * @return {DomElement[]}\n\t\t */\n\t\tgetNodes: function () {\n\t\t\treturn this._nodes;\n\t\t},\n\n\t\t/**\n\t\t * Sets the nodes of the dom-element\n\t\t *\n\t\t * @method setNodes\n\t\t * @param {object|DomElement[]} value\n\t\t */\n\t\tsetNodes: function (value) {\n\n\t\t\tvar list = [];\n\n\t\t\tvalue.forEach(function (node) {\n\t\t\t\tnode.parent = this;\n\t\t\t\tlist.push(this._parseObject(node, DomElement, 'dom-element'));\n\t\t\t}.bind(this));\n\n\t\t\tthis._nodes = list;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the selector for this DOM-element\n\t\t *\n\t\t * @param {string} [suffix]\n\t\t * @return {string}\n\t\t */\n\t\tgetSelector: function (suffix) {\n\n\t\t\tvar id = this.getId(),\n\t\t\t\ttagName = this.getTagName(),\n\t\t\t\tclasses = this.getClasses(),\n\t\t\t\tresult;\n\n\t\t\tif (id) {\n\t\t\t\treturn '#' + id + ' ' + suffix;\n\n\t\t\t} else if (classes && classes.length > 0) {\n\t\t\t\tresult = '.' + classes.join('.') + ' ' + suffix;\n\n\t\t\t\tif (tagName) {\n\t\t\t\t\tresult = tagName + result;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tresult = tagName + ' ' + suffix;\n\t\t\t}\n\n\t\t\tif (this.hasParent()) {\n\t\t\t\treturn this.getParent().getSelector(result);\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Finds a DOM-element at an absolute coordinate\n\t\t *\n\t\t * @method findElementAt\n\t\t * @param {int} x X-coordinate\n\t\t * @param {int} y Y-coordinate\n\t\t */\n\t\tfindElementAt: function (x, y) {\n\n\t\t\tvar nodes,\n\t\t\t\tresult,\n\t\t\t\ti;\n\n\t\t\tif (this.getRect().inBounds(x, y)) {\n\t\t\t\treturn this;\n\n\t\t\t} else {\n\t\t\t\tnodes = this.getNodes();\n\n\t\t\t\tif (nodes) {\n\n\t\t\t\t\t// Travers from the back so that overlapping elements will be selected first\n\t\t\t\t\tfor (i = nodes.length; i >= 0; i--) {\n\t\t\t\t\t\tresult = nodes[i].findElementAt(x, y);\n\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_DOM_ELEMENT'\n\t}\n);\n\nmodule.exports = DomElement;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/pixelComparison.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar Color = require('./atoms/color');\nvar Rect = require('./atoms/rect');\nvar Shift = require('./shift');\nvar BlockOut = require('./blockOut');\n\n/**\n * @class PixelComparison\n * @extends Base\n * @module Configuration\n *\n * @property {string} _type\n * @property {number} _colorDelta\n * @property {number} _colorDeltaSquared\n * @property {Color} _gamma\n * @property {boolean} _perceptual\n * @property {string[]} _filters\n * @property {Shift} _shift\n * @property {BlockOut[]} _blockOuts\n * @property {Rect} _areaImageA\n * @property {Rect} _areaImageB\n */\nvar PixelComparison = Base.extend(\n\n\t/**\n\t * Pixel-comparison constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.type Type of comparison\n\t * @param {number} options.colorDelta Max. delta of colors before triggering difference\n\t * @param {object|Color} options.gamma Gamma correction for perceptual comparisons\n\t * @param {boolean} options.perceptual Active/deactivate perceptual comparison\n\t * @param {string[]} options.filters Comparison filters (i.e. \"blur\" to reduce sub-pixel issues)\n\t * @param {object|Shift} options.shift Pixel shifting\n\t * @param {object[]|BlockOut[]} options.blockOuts List of areas to block-out\n\t * @param {object|Rect} [options.areaImageA] Area of comparison in Image A\n\t * @param {object|Rect} [options.areaImageB] Area of comparison in Image B\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\ttype: \"pixel\",\n\t\t\tcolorDelta: 20,\n\t\t\tgamma: null,\n\t\t\tperceptual: false,\n\t\t\tfilters: [],\n\t\t\tshift: {},\n\t\t\tblockOuts: []\n\t\t}, [options]);\n\n\t\tthis.setType(options.type);\n\t\tthis.setColorDelta(options.colorDelta);\n\n\t\tif (options.gamma) {\n\t\t\tthis.setGamma(options.gamma);\n\t\t}\n\t\tthis.setPerceptual(options.perceptual);\n\t\tthis.setFilters(options.filters);\n\n\t\tthis.setShift(options.shift);\n\n\t\tthis.setBlockOuts(options.blockOuts);\n\n\t\tif (options.areaImageA) {\n\t\t\tthis.setAreaImageA(options.areaImageA);\n\t\t}\n\t\tif (options.areaImageB) {\n\t\t\tthis.setAreaImageB(options.areaImageB);\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the comparison type\n\t\t *\n\t\t * @method getType\n\t\t * @return {string}\n\t\t */\n\t\tgetType: function () {\n\t\t\treturn this._type;\n\t\t},\n\n\t\t/**\n\t\t * Sets the comparison type\n\t\t *\n\t\t * @method setType\n\t\t * @param {string} value\n\t\t */\n\t\tsetType: function (value) {\n\t\t\tthis._type = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the max. delta for color differences before triggering it\n\t\t *\n\t\t * @method getColorDelta\n\t\t * @return {number}\n\t\t */\n\t\tgetColorDelta: function () {\n\t\t\treturn this._colorDelta;\n\t\t},\n\n\t\t/**\n\t\t * Gets the max. delta for color differences before triggering it\n\t\t * This value is squared to reduce Math.sqrt during comparison.\n\t\t *\n\t\t * @method getColorDeltaSquared\n\t\t * @return {number}\n\t\t */\n\t\tgetColorDeltaSquared: function () {\n\t\t\treturn this._colorDeltaSquared;\n\t\t},\n\n\t\t/**\n\t\t * Sets the max. delta for color differences before triggering it\n\t\t *\n\t\t * @method setColorDelta\n\t\t * @param {number} value\n\t\t */\n\t\tsetColorDelta: function (value) {\n\t\t\tthis._colorDelta = value;\n\t\t\tthis._colorDeltaSquared = Math.pow(value, 2);\n\t\t},\n\n\n\t\t/**\n\t\t * Is gamma available?\n\t\t *\n\t\t * @method hasGamma\n\t\t * @return {boolean}\n\t\t */\n\t\thasGamma: function () {\n\t\t\treturn !!this._gamma;\n\t\t},\n\n\t\t/**\n\t\t * Gets the gamma\n\t\t *\n\t\t * @method getGamma\n\t\t * @return {Color}\n\t\t */\n\t\tgetGamma: function () {\n\t\t\treturn this._gamma;\n\t\t},\n\n\t\t/**\n\t\t * Sets the gamma\n\t\t *\n\t\t * @method setGamma\n\t\t * @param {object|Color} value\n\t\t */\n\t\tsetGamma: function (value) {\n\t\t\tthis._gamma = this._parseObject(value, Color, 'color');\n\t\t},\n\n\n\t\t/**\n\t\t * Is the comparison perceptual?\n\t\t *\n\t\t * @method isPerceptual\n\t\t * @return {boolean}\n\t\t */\n\t\tisPerceptual: function () {\n\t\t\treturn this._perceptual;\n\t\t},\n\n\t\t/**\n\t\t * Sets if the comparison is perceptual\n\t\t *\n\t\t * @method setPerceptual\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetPerceptual: function (value) {\n\t\t\tthis._perceptual = !!value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets all filters that will be applied to the images before comparison\n\t\t *\n\t\t * @method getFilters\n\t\t * @return {string[]}\n\t\t */\n\t\tgetFilters: function () {\n\t\t\treturn this._filters;\n\t\t},\n\n\t\t/**\n\t\t * Sets all filters that should be applied to the images before comparison\n\t\t *\n\t\t * @method setFilters\n\t\t * @param {string[]} value\n\t\t */\n\t\tsetFilters: function (value) {\n\t\t\tthis._filters = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the shift\n\t\t *\n\t\t * @method getShift\n\t\t * @return {Shift}\n\t\t */\n\t\tgetShift: function () {\n\t\t\treturn this._shift;\n\t\t},\n\n\t\t/**\n\t\t * Sets the shift\n\t\t *\n\t\t * @method setShift\n\t\t * @param {object|Shift} value\n\t\t */\n\t\tsetShift: function (value) {\n\t\t\tthis._shift = this._parseObject(value, Shift, 'shift');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the block-outs\n\t\t *\n\t\t * @method getBlockOuts\n\t\t * @return {BlockOut[]}\n\t\t */\n\t\tgetBlockOuts: function () {\n\t\t\treturn this._blockOuts;\n\t\t},\n\n\t\t/**\n\t\t * Sets the block-outs\n\t\t *\n\t\t * @method setBlockOuts\n\t\t * @param {object[]|BlockOut[]} value\n\t\t */\n\t\tsetBlockOuts: function (value) {\n\n\t\t\tvar list = [];\n\n\t\t\tvalue.forEach(function (blockOut) {\n\t\t\t\tlist.push(this._parseObject(blockOut, BlockOut, 'block-out'));\n\t\t\t}.bind(this));\n\n\t\t\tthis._blockOuts = list;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the area rectangle for image A\n\t\t *\n\t\t * @method getAreaImageA\n\t\t * @return {Rect}\n\t\t */\n\t\tgetAreaImageA: function () {\n\t\t\treturn this._areaImageA;\n\t\t},\n\n\t\t/**\n\t\t * Sets the area rectangle for image A\n\t\t *\n\t\t * @method setAreaImageA\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetAreaImageA: function (value) {\n\t\t\tthis._areaImageA = this._parseObject(value, Rect, 'rect A');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the area rectangle for image B\n\t\t *\n\t\t * @method getAreaImageB\n\t\t * @return {Rect}\n\t\t */\n\t\tgetAreaImageB: function () {\n\t\t\treturn this._areaImageB;\n\t\t},\n\n\t\t/**\n\t\t * Sets the area rectangle for image B\n\t\t *\n\t\t * @method setAreaImageB\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetAreaImageB: function (value) {\n\t\t\tthis._areaImageB = this._parseObject(value, Rect, 'rect B');\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_PIXEL_COMPARISON'\n\t}\n);\n\nmodule.exports = PixelComparison;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/atoms/color.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\nvar utils = require('preceptor-core').utils;\n\n/**\n * @class Color\n * @extends Base\n * @module Configuration\n * @submodule Atoms\n *\n * @property {number} _red\n * @property {number} _green\n * @property {number} _blue\n * @property {number} _alpha\n * @property {float} _opacity\n */\nvar Color = Base.extend(\n\n\t/**\n\t * Color constructor\n\t *\n\t * @param {object} options\n\t * @param {number} options.red Red channel\n\t * @param {number} options.green Green channel\n\t * @param {number} options.blue Blue channel\n\t * @param {number} options.alpha Alpha Channel\n\t * @param {float} options.opacity Opacity of color\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\tred: 0,\n\t\t\tgreen: 0,\n\t\t\tblue: 0,\n\t\t\talpha: 255,\n\t\t\topacity: 1.0\n\t\t}, [options]);\n\n\t\tthis.setRed(options.red);\n\t\tthis.setGreen(options.green);\n\t\tthis.setBlue(options.blue);\n\t\tthis.setAlpha(options.alpha);\n\t\tthis.setOpacity(options.opacity);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the red channel\n\t\t *\n\t\t * @method getRed\n\t\t * @return {number}\n\t\t */\n\t\tgetRed: function () {\n\t\t\treturn this._red;\n\t\t},\n\n\t\t/**\n\t\t * Sets the red channel\n\t\t *\n\t\t * @method setRed\n\t\t * @param {number} value\n\t\t */\n\t\tsetRed: function (value) {\n\t\t\tthis._red = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the green channel\n\t\t *\n\t\t * @method getGreen\n\t\t * @return {number}\n\t\t */\n\t\tgetGreen: function () {\n\t\t\treturn this._green;\n\t\t},\n\n\t\t/**\n\t\t * Sets the green channel\n\t\t *\n\t\t * @method setGreen\n\t\t * @param {number} value\n\t\t */\n\t\tsetGreen: function (value) {\n\t\t\tthis._green = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the blue channel\n\t\t *\n\t\t * @method getBlue\n\t\t * @return {number}\n\t\t */\n\t\tgetBlue: function () {\n\t\t\treturn this._blue;\n\t\t},\n\n\t\t/**\n\t\t * Sets the blue channel\n\t\t *\n\t\t * @method setBlue\n\t\t * @param {number} value\n\t\t */\n\t\tsetBlue: function (value) {\n\t\t\tthis._blue = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the alpha channel\n\t\t *\n\t\t * @method getAlpha\n\t\t * @return {number}\n\t\t */\n\t\tgetAlpha: function () {\n\t\t\treturn this._alpha;\n\t\t},\n\n\t\t/**\n\t\t * Sets the alpha channel\n\t\t *\n\t\t * @method setAlpha\n\t\t * @param {number} value\n\t\t */\n\t\tsetAlpha: function (value) {\n\t\t\tthis._alpha = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the opacity of the color\n\t\t *\n\t\t * @method getOpacity\n\t\t * @return {float}\n\t\t */\n\t\tgetOpacity: function () {\n\t\t\treturn this._opacity;\n\t\t},\n\n\t\t/**\n\t\t * Sets the opacity of the color\n\t\t *\n\t\t * @method setOpacity\n\t\t * @param {float} value\n\t\t */\n\t\tsetOpacity: function (value) {\n\t\t\tthis._opacity = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets all color channels as one color object\n\t\t *\n\t\t * @method getColor\n\t\t * @param {boolean} [alpha=false] Output alpha channel?\n\t\t * @param {boolean} [opacity=false] Output opacity?\n\t\t * @return {{red: (number), green: (number), blue: (number)[, alpha: (number)][, opacity: (float)]}}\n\t\t */\n\t\tgetColor: function (alpha, opacity) {\n\n\t\t\tvar result = {\n\t\t\t\tred: this.getRed(),\n\t\t\t\tgreen: this.getGreen(),\n\t\t\t\tblue: this.getBlue()\n\t\t\t};\n\n\t\t\tif (alpha) {\n\t\t\t\tresult.alpha = this.getAlpha();\n\t\t\t}\n\n\t\t\tif (opacity) {\n\t\t\t\tresult.opacity = this.getOpacity();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Gets all color channels as one color object with short descriptions\n\t\t *\n\t\t * @method getShortColor\n\t\t * @param {boolean} [alpha=false] Output alpha channel?\n\t\t * @param {boolean} [opacity=false] Output opacity?\n\t\t * @return {{r: (number), g: (number), b: (number)[, a: (number)][, o: (float)]}}\n\t\t */\n\t\tgetShortColor: function (alpha, opacity) {\n\n\t\t\tvar result = {\n\t\t\t\tr: this.getRed(),\n\t\t\t\tg: this.getGreen(),\n\t\t\t\tb: this.getBlue()\n\t\t\t};\n\n\n\t\t\tif (alpha) {\n\t\t\t\tresult.a = this.getAlpha();\n\t\t\t}\n\n\t\t\tif (opacity) {\n\t\t\t\tresult.o = this.getOpacity();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_ATOM_COLOR'\n\t}\n);\n\nmodule.exports = Color;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/shift.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\n/**\n * @class Shift\n * @extends Base\n * @module Configuration\n *\n * @property {boolean} _active\n * @property {int} _horizontal\n * @property {int} _vertical\n * @property {boolean} _visible\n */\nvar Shift = Base.extend(\n\n\t/**\n\t * Shift constructor\n\t *\n\t * @param {object} options\n\t * @param {boolean} options.active Shift activated?\n\t * @param {int} options.horizontal Max. horizontal shift\n\t * @param {int} options.vertical Max. vertical shift\n\t * @param {boolean} options.visible Visible\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\tactive: true,\n\t\t\thorizontal: 2,\n\t\t\tvertical: 2,\n\t\t\tvisible: true\n\t\t}, [options]);\n\n\t\tif (options.active) {\n\t\t\tthis.activate();\n\t\t} else {\n\t\t\tthis.deactivate();\n\t\t}\n\n\t\tthis.setHorizontal(options.horizontal);\n\t\tthis.setVertical(options.vertical);\n\n\t\tthis.setVisibility(options.visible);\n\t},\n\n\t{\n\t\t/**\n\t\t * Is shifting activated?\n\t\t *\n\t\t * @method isActive\n\t\t * @return {boolean}\n\t\t */\n\t\tisActive: function () {\n\t\t\treturn this._active;\n\t\t},\n\n\t\t/**\n\t\t * Activates shift highlighting\n\t\t *\n\t\t * @method activate\n\t\t */\n\t\tactivate: function () {\n\t\t\tthis._activate = true;\n\t\t},\n\n\t\t/**\n\t\t * Deactivates shift highlighting\n\t\t *\n\t\t * @method deactivate\n\t\t */\n\t\tdeactivate: function () {\n\t\t\tthis._active = false;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the max. horizontal shift\n\t\t *\n\t\t * @method getHorizontal\n\t\t * @return {int}\n\t\t */\n\t\tgetHorizontal: function () {\n\t\t\treturn this._horizontal;\n\t\t},\n\n\t\t/**\n\t\t * Sets the max. horizontal shift\n\t\t *\n\t\t * @method setHorizontal\n\t\t * @param {int} value\n\t\t */\n\t\tsetHorizontal: function (value) {\n\t\t\tthis._horizontal = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the max. vertical shift\n\t\t *\n\t\t * @method getVertical\n\t\t * @return {int}\n\t\t */\n\t\tgetVertical: function () {\n\t\t\treturn this._vertical;\n\t\t},\n\n\t\t/**\n\t\t * Sets the max. vertical shift\n\t\t *\n\t\t * @method setVertical\n\t\t * @param {int} value\n\t\t */\n\t\tsetVertical: function (value) {\n\t\t\tthis._vertical = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Is shift visible in final result\n\t\t *\n\t\t * @method isVisible\n\t\t * @return {boolean}\n\t\t */\n\t\tisVisible: function () {\n\t\t\treturn this._visible;\n\t\t},\n\n\t\t/**\n\t\t * Sets the visibility of the shift in final result\n\t\t *\n\t\t * @method setVisibility\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetVisibility: function (value) {\n\t\t\tthis._visible = !!value;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_SHIFT'\n\t}\n);\n\nmodule.exports = Shift;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/blockOut.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar Color = require('./atoms/color');\nvar Rect = require('./atoms/rect');\n\n/**\n * @class BlockOut\n * @extends Base\n * @module Configuration\n *\n * @property {boolean} _visible\n * @property {Color} _color\n * @property {Rect} _area\n */\nvar BlockOut = Base.extend(\n\n\t/**\n\t * BlockOut constructor\n\t *\n\t * @param {object} options\n\t * @param {boolean} options.visible\n\t * @param {object|Color} options.color\n\t * @param {object|Rect} options.area\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\tvisible: false,\n\t\t\tcolor: {},\n\t\t\tarea: {}\n\t\t}, [options]);\n\n\t\tthis.setVisibility(options.visible);\n\t\tthis.setColor(options.color);\n\t\tthis.setAreaRect(options.area);\n\t},\n\n\t{\n\t\t/**\n\t\t * Is block-out visible in final result\n\t\t *\n\t\t * @method isVisible\n\t\t * @return {boolean}\n\t\t */\n\t\tisVisible: function () {\n\t\t\treturn this._visible;\n\t\t},\n\n\t\t/**\n\t\t * Sets the visibility of the block-out in final result\n\t\t *\n\t\t * @method setVisibility\n\t\t * @param {boolean} value\n\t\t */\n\t\tsetVisibility: function (value) {\n\t\t\tthis._visible = !!value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the color\n\t\t *\n\t\t * @method getColor\n\t\t * @return {Color}\n\t\t */\n\t\tgetColor: function () {\n\t\t\treturn this._color;\n\t\t},\n\n\t\t/**\n\t\t * Sets the color\n\t\t *\n\t\t * @method setColor\n\t\t * @param {object|Color} value\n\t\t */\n\t\tsetColor: function (value) {\n\t\t\tthis._color = this._parseObject(value, Color, 'color');\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the area rectangle\n\t\t *\n\t\t * @method getAreaRect\n\t\t * @return {Rect}\n\t\t */\n\t\tgetAreaRect: function () {\n\t\t\treturn this._area;\n\t\t},\n\n\t\t/**\n\t\t * Sets the area rectangle\n\t\t *\n\t\t * @method setAreaRect\n\t\t * @param {object|Rect} value\n\t\t */\n\t\tsetAreaRect: function (value) {\n\t\t\tthis._area = this._parseObject(value, Rect, 'rect');\n\t\t},\n\n\n\t\t/**\n\t\t * Post-process image after creating result image base\n\t\t *\n\t\t * @method processImage\n\t\t * @param {PNGImage} image\n\t\t * @return {PNGImage}\n\t\t */\n\t\tprocessImage: function (image) {\n\t\t\tthis._blockOut(image);\n\t\t\treturn image;\n\t\t},\n\n\t\t/**\n\t\t * Blocks-out an area of the image\n\t\t *\n\t\t * @method _blockOut\n\t\t * @param {PNGImage} image\n\t\t * @private\n\t\t */\n\t\t_blockOut: function (image) {\n\n\t\t\tvar rect,\n\t\t\t\tcoord,\n\t\t\t\tcolor;\n\n\t\t\trect = this.getAreaRect().clone();\n\t\t\trect.limitCoordinates(new Rect({\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\twidth: image.getWidth(),\n\t\t\t\theight: image.getHeight()\n\t\t\t}));\n\n\t\t\tcoord = rect.getCoordinates();\n\t\t\tcolor = this.getColor().getColor(true, true);\n\n\t\t\timage.fillRect(coord.x, coord.y, coord.width, coord.height, color);\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_BLOCK_OUT'\n\t}\n);\n\nmodule.exports = BlockOut;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/structureComparison.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar Color = require('./atoms/color');\nvar Rect = require('./atoms/rect');\nvar Shift = require('./shift');\nvar BlockOut = require('./blockOut');\n\n/**\n * @class StructureComparison\n * @extends Base\n * @module Configuration\n *\n * @property {string} _type\n * @property {string} _selector\n * @property {Anchor[]} _anchors\n * @property {Limit[]} _limits\n */\nvar StructureComparison = Base.extend(\n\n\t/**\n\t * Structural comparison constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.type Type of comparison\n\t * @param {string} options.selector Selector for checked DOM-element\n\t * @param {object[]|Anchor[]} options.anchors Anchors for DOM-element\n\t * @param {object[]|Limit[]} options.limits Limits for selecting DOM-elements\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\ttype: \"structure\",\n\t\t\tselector: null,\n\t\t\tanchors: [],\n\t\t\tlimits: []\n\t\t}, [options]);\n\n\t\tthis.setType(options.type);\n\t\tthis.setSelector(options.selector);\n\n\t\tthis.setAnchors(options.anchors);\n\t\tthis.setLimits(options.limits);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the comparison type\n\t\t *\n\t\t * @method getType\n\t\t * @return {string}\n\t\t */\n\t\tgetType: function () {\n\t\t\treturn this._type;\n\t\t},\n\n\t\t/**\n\t\t * Sets the comparison type\n\t\t *\n\t\t * @method setType\n\t\t * @param {string} value\n\t\t */\n\t\tsetType: function (value) {\n\t\t\tthis._type = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the selector for a DOM element\n\t\t *\n\t\t * @method getSelector\n\t\t * @return {string}\n\t\t */\n\t\tgetSelector: function () {\n\t\t\treturn this._selector;\n\t\t},\n\n\t\t/**\n\t\t * Sets the selector for a DOM element\n\t\t *\n\t\t * @method setSelector\n\t\t * @param {string} value\n\t\t */\n\t\tsetSelector: function (value) {\n\t\t\tthis._selector = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the anchors for DOM-elements\n\t\t *\n\t\t * @method getAnchors\n\t\t * @return {Anchor[]}\n\t\t */\n\t\tgetAnchors: function () {\n\t\t\treturn this._anchors;\n\t\t},\n\n\t\t/**\n\t\t * Sets the anchors for DOM-elements\n\t\t *\n\t\t * @method setAnchors\n\t\t * @param {object[]|Anchor[]} value\n\t\t */\n\t\tsetAnchors: function (value) {\n\n\t\t\tvar list = [];\n\n\t\t\tvalue.forEach(function (entry) {\n\t\t\t\tlist.push(this._parseObject(entry, Anchor, 'anchor'));\n\t\t\t}.bind(this));\n\n\t\t\tthis._anchors = list;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the limitations for selection\n\t\t *\n\t\t * @method getLimits\n\t\t * @return {Limit[]}\n\t\t */\n\t\tgetLimits: function () {\n\t\t\treturn this._limits;\n\t\t},\n\n\t\t/**\n\t\t * Sets the limitations or selection\n\t\t *\n\t\t * @method setLimits\n\t\t * @param {object[]|Limit[]} value\n\t\t */\n\t\tsetLimits: function (value) {\n\n\t\t\tvar list = [];\n\n\t\t\tvalue.forEach(function (entry) {\n\t\t\t\tlist.push(this._parseObject(entry, Limit, 'limit'));\n\t\t\t}.bind(this));\n\n\t\t\tthis._limits = list;\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_STRUCTURE_COMPARISON'\n\t}\n);\n\nmodule.exports = StructureComparison;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/atoms/threshold.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('../base');\nvar utils = require('preceptor-core').utils;\n\nvar constants = require('../../constants');\n\n/**\n * @class Threshold\n * @extends Base\n * @module Configuration\n * @submodule Atoms\n *\n * @property {string} _type\n * @property {number} _value\n */\nvar Threshold = Base.extend(\n\n\t/**\n\t * Threshold constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.type Type of threshold\n\t * @param {number} options.value Value of threshold\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\ttype: 'pixel',\n\t\t\tvalue: 1\n\t\t}, [options]);\n\n\t\tthis.setType(options.type);\n\t\tthis.setValue(options.value);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the type of the threshold\n\t\t *\n\t\t * @method getType\n\t\t * @return {string}\n\t\t */\n\t\tgetType: function () {\n\t\t\treturn this._type;\n\t\t},\n\n\t\t/**\n\t\t * Sets the type of the threshold\n\t\t *\n\t\t * @method setType\n\t\t * @param {string} value\n\t\t */\n\t\tsetType: function (value) {\n\t\t\tthis._type = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the value of the threshold\n\t\t *\n\t\t * @method getValue\n\t\t * @return {number}\n\t\t */\n\t\tgetValue: function () {\n\t\t\treturn this._value;\n\t\t},\n\n\t\t/**\n\t\t * Sets the value of the threshold\n\t\t *\n\t\t * @method setValue\n\t\t * @param {number} value\n\t\t */\n\t\tsetValue: function (value) {\n\t\t\tthis._value = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Is the difference above the set threshold?\n\t\t *\n\t\t * @method isAboveThreshold\n\t\t * @param {int} items\n\t\t * @param {int} [total]\n\t\t * @return {boolean}\n\t\t */\n\t\tisAboveThreshold: function (items, total) {\n\n\t\t\tif (this.isPixel() && (this.getValue() <= items)) {\n\t\t\t\treturn true;\n\n\t\t\t} else if (this.getValue() <= (items / total)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * Is percentage threshold?\n\t\t *\n\t\t * @method isPercentage\n\t\t * @return {boolean}\n\t\t */\n\t\tisPercentage: function () {\n\t\t\treturn (this.getType() == constants.THRESHOLD_PERCENT);\n\t\t},\n\n\t\t/**\n\t\t * Is pixel threshold?\n\t\t *\n\t\t * @method isPixel\n\t\t * @return {boolean}\n\t\t */\n\t\tisPixel: function () {\n\t\t\treturn (this.getType() == constants.THRESHOLD_PIXEL);\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_ATOM_THRESHOLD'\n\t}\n);\n\nmodule.exports = Threshold;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/constants.js":"/**\n * @class constants\n * @type {object}\n */\nmodule.exports = {\n\n\t/**\n\t * Anchor-type left\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_LEFT\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_LEFT: 'left',\n\n\t/**\n\t * Anchor-type right\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_RIGHT\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_RIGHT: 'right',\n\n\t/**\n\t * Anchor-type top\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_TOP\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_TOP: 'top',\n\n\t/**\n\t * Anchor-type bottom\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_BOTTOM\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_BOTTOM: 'bottom',\n\n\t/**\n\t * Anchor-type width\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_WIDTH\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_WIDTH: 'width',\n\n\t/**\n\t * Anchor-type height\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_HEIGHT\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_HEIGHT: 'height',\n\n\t/**\n\t * Anchor-type horizontal (includes width, left, and right)\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_HORIZONTAL\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_HORIZONTAL: 'horizontal',\n\n\t/**\n\t * Anchor-type vertical (includes height, top, and bottom)\n\t *\n\t * @static\n\t * @property ANCHOR_TYPE_VERTICAL\n\t * @type {string}\n\t */\n\tANCHOR_TYPE_VERTICAL: 'vertical',\n\n\n\t/**\n\t * Relative positioning\n\t *\n\t * @static\n\t * @property ANCHOR_POSITION_RELATIVE\n\t * @type {string}\n\t */\n\tANCHOR_POSITION_RELATIVE: 'relative',\n\n\t/**\n\t * Absolute positioning\n\t *\n\t * @static\n\t * @property ANCHOR_POSITION_ABSOLUTE\n\t * @type {string}\n\t */\n\tANCHOR_POSITION_ABSOLUTE: 'absolute',\n\n\n\t/**\n\t * Limit-type min\n\t *\n\t * @static\n\t * @property LIMIT_TYPE_MIN\n\t * @type {string}\n\t */\n\tLIMIT_TYPE_MIN: 'min',\n\n\t/**\n\t * Limit-type max\n\t *\n\t * @static\n\t * @property LIMIT_TYPE_MAX\n\t * @type {string}\n\t */\n\tLIMIT_TYPE_MAX: 'max',\n\n\n\t/**\n\t * Limit-context left\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_LEFT\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_LEFT: 'left',\n\n\t/**\n\t * Limit-context right\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_RIGHT\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_RIGHT: 'right',\n\n\t/**\n\t * Limit-context top\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_TOP\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_TOP: 'top',\n\n\t/**\n\t * Limit-context bottom\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_BOTTOM\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_BOTTOM: 'bottom',\n\n\t/**\n\t * Limit-context width\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_WIDTH\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_WIDTH: 'width',\n\n\t/**\n\t * Limit-context height\n\t *\n\t * @static\n\t * @property LIMIT_CONTEXT_HEIGHT\n\t * @type {string}\n\t */\n\tLIMIT_CONTEXT_HEIGHT: 'height',\n\n\n\t/**\n\t * Threshold-type for pixel\n\t *\n\t * @static\n\t * @property THRESHOLD_PIXEL\n\t * @type {string}\n\t */\n\tTHRESHOLD_PIXEL: 'pixel',\n\n\t/**\n\t * Threshold-type for percent of all pixels\n\t *\n\t * @static\n\t * @property THRESHOLD_PERCENT\n\t * @type {string}\n\t */\n\tTHRESHOLD_PERCENT: 'percent',\n\n\n\t/**\n\t * Comparison-type for pixel\n\t *\n\t * @static\n\t * @property COMPARISON_PIXEL\n\t * @type {string}\n\t */\n\tCOMPARISON_PIXEL: 'pixel',\n\n\t/**\n\t * Comparison-type for structure\n\t *\n\t * @static\n\t * @property COMPARISON_STRUCTURE\n\t * @type {string}\n\t */\n\tCOMPARISON_STRUCTURE: 'structure',\n\n\n\t/**\n\t * Unknown result of the comparison\n\t *\n\t * @static\n\t * @property RESULT_UNKNOWN\n\t * @type {int}\n\t */\n\tRESULT_UNKNOWN: 0,\n\n\t/**\n\t * The images are too different\n\t *\n\t * @static\n\t * @property RESULT_DIFFERENT\n\t * @type {int}\n\t */\n\tRESULT_DIFFERENT: 10,\n\n\t/**\n\t * The images are very similar, but still below the threshold\n\t *\n\t * @static\n\t * @property RESULT_SIMILAR\n\t * @type {int}\n\t */\n\tRESULT_SIMILAR: 20,\n\n\t/**\n\t * The images are identical (or near identical)\n\t *\n\t * @static\n\t * @property RESULT_IDENTICAL\n\t * @type {int}\n\t */\n\tRESULT_IDENTICAL: 30,\n\n\n\t/**\n\t * Create output when images are different\n\t *\n\t * @static\n\t * @property OUTPUT_DIFFERENT\n\t * @type {int}\n\t */\n\tOUTPUT_DIFFERENT: 10,\n\n\t/**\n\t * Create output when images are similar or different\n\t *\n\t * @static\n\t * @property OUTPUT_SIMILAR\n\t * @type {int}\n\t */\n\tOUTPUT_SIMILAR: 20,\n\n\t/**\n\t * Force output of all comparisons\n\t *\n\t * @static\n\t * @property OUTPUT_ALL\n\t * @type {int}\n\t */\n\tOUTPUT_ALL: 100,\n\n\n\t/**\n\t * Composition is off\n\t *\n\t * @static\n\t * @property COMPOSITION_OFF\n\t * @type {int}\n\t */\n\tCOMPOSITION_OFF: 0,\n\n\t/**\n\t * Automatic composition depending on the resolutions of the images\n\t *\n\t * @static\n\t * @property COMPOSITION_AUTO\n\t * @type {int}\n\t */\n\tCOMPOSITION_AUTO: 1,\n\n\t/**\n\t * Composition from left to right\n\t *\n\t * @static\n\t * @property COMPOSITION_LEFT_TO_RIGHT\n\t * @type {int}\n\t */\n\tCOMPOSITION_LEFT_TO_RIGHT: 2,\n\n\t/**\n\t * Composition from top to bottom\n\t *\n\t * @static\n\t * @property COMPOSITION_TOP_TO_BOTTOM\n\t * @type {int}\n\t */\n\tCOMPOSITION_TOP_TO_BOTTOM: 3,\n\n\n\t/**\n\t * Do not copy any image to the result\n\t *\n\t * @static\n\t * @property COPY_IMAGE_OFF\n\t * @type {int}\n\t */\n\tCOPY_IMAGE_OFF: 0,\n\n\t/**\n\t * Copy image A as base for result\n\t *\n\t * @static\n\t * @property COPY_IMAGE_A\n\t * @type {int}\n\t */\n\tCOPY_IMAGE_A: 1,\n\n\t/**\n\t * Copy image B as base for result\n\t *\n\t * @static\n\t * @property COPY_IMAGE_B\n\t * @type {int}\n\t */\n\tCOPY_IMAGE_B: 2\n};\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/output.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar constants = require('../constants');\n\n/**\n * @class Output\n * @extends Base\n * @module Configuration\n *\n * @property {string} _imagePath\n * #property {int} _limit\n * @property {int} _composition\n * @property {int} _copyImage\n */\nvar Output = Base.extend(\n\n\t/**\n\t * Output constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.imagePath Path to the output image\n\t * @param {int} options.limit Limiting options for output image\n\t * @param {int} options.composition Composition options for output image\n\t * @param {int} options.copyImage Copy-image options for output image\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\timagePath: null,\n\t\t\tlimit: constants.OUTPUT_DIFFERENT,\n\t\t\tcomposition: constants.COMPOSITION_AUTO,\n\t\t\tcopyImage: constants.COPY_IMAGE_B\n\t\t}, [options]);\n\n\t\tthis.setImagePath(options.imagePath);\n\n\t\tthis.setLimitMode(options.limit);\n\t\tthis.setCompositionMode(options.composition);\n\t\tthis.setCopyImage(options.copyImage);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the path of the output image\n\t\t *\n\t\t * @method getImagePath\n\t\t * @return {string}\n\t\t */\n\t\tgetImagePath: function () {\n\t\t\treturn this._imagePath;\n\t\t},\n\n\t\t/**\n\t\t * Sets the path of the output image\n\t\t *\n\t\t * @method setImagePath\n\t\t * @param {string} path\n\t\t */\n\t\tsetImagePath: function (path) {\n\t\t\tthis._imagePath = path;\n\t\t},\n\n\t\t/**\n\t\t * Writes the image to a file if a path was given\n\t\t *\n\t\t * @method writeImage\n\t\t * @param {PNGImage} image\n\t\t * @return {boolean} Written?\n\t\t */\n\t\twriteImage: function (image) {\n\t\t\tif (this.getImagePath()) {\n\t\t\t\timage.writeImageSync(this.getImagePath());\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the limit mode\n\t\t *\n\t\t * @method getLimitMode\n\t\t * @return {int}\n\t\t */\n\t\tgetLimitMode: function () {\n\t\t\treturn this._limit;\n\t\t},\n\n\t\t/**\n\t\t * Sets the limit mode\n\t\t *\n\t\t * @method setLimitMode\n\t\t * @param {int} value\n\t\t */\n\t\tsetLimitMode: function (value) {\n\t\t\tthis._limit = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Is there an output limit?\n\t\t *\n\t\t * @method hasLimit\n\t\t * @return {boolean}\n\t\t */\n\t\thasLimit: function () {\n\t\t\treturn (this.getLimitMode() != constants.OUTPUT_ALL);\n\t\t},\n\n\t\t/**\n\t\t * Is the output-limit for different images only?\n\t\t *\n\t\t * @method isLimitDifferent\n\t\t * @return {boolean}\n\t\t */\n\t\tisLimitDifferent: function () {\n\t\t\treturn (this.getLimitMode() == constants.OUTPUT_DIFFERENT);\n\t\t},\n\n\t\t/**\n\t\t * Is the output-limit for similar and different images?\n\t\t *\n\t\t * @method isLimitSimilar\n\t\t * @return {boolean}\n\t\t */\n\t\tisLimitSimilar: function () {\n\t\t\treturn (this.getLimitMode() == constants.OUTPUT_SIMILAR);\n\t\t},\n\n\t\t/**\n\t\t * Determines if a result-code is within the output limits\n\t\t *\n\t\t * @method withinOutputLimit\n\t\t * @param resultCode\n\t\t * @return {boolean}\n\t\t */\n\t\twithinOutputLimit: function (resultCode) {\n\t\t\tif (!this.hasLimit()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn resultCode <= this.getLimitMode();\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the composition mode\n\t\t *\n\t\t * @method getCompositionMode\n\t\t * @return {int}\n\t\t */\n\t\tgetCompositionMode: function () {\n\t\t\treturn this._composition;\n\t\t},\n\n\t\t/**\n\t\t * Sets the composition mode\n\t\t *\n\t\t * @method setCompositionMode\n\t\t * @param {int} value\n\t\t */\n\t\tsetCompositionMode: function (value) {\n\t\t\tthis._composition = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Is composition off?\n\t\t *\n\t\t * @method isCompositionOff\n\t\t * @return {boolean}\n\t\t */\n\t\tisCompositionOff: function () {\n\t\t\treturn (this.getCompositionMode() == constants.COMPOSITION_OFF);\n\t\t},\n\n\t\t/**\n\t\t * Is composition in auto-mode?\n\t\t *\n\t\t * @method isAutoComposition\n\t\t * @return {boolean}\n\t\t */\n\t\tisAutoComposition: function () {\n\t\t\treturn (this.getCompositionMode() == constants.COMPOSITION_AUTO);\n\t\t},\n\n\t\t/**\n\t\t * Is composition from left to right?\n\t\t *\n\t\t * @method isCompositionLeftToRight\n\t\t * @return {boolean}\n\t\t */\n\t\tisCompositionLeftToRight: function () {\n\t\t\treturn (this.getCompositionMode() == constants.COMPOSITION_LEFT_TO_RIGHT);\n\t\t},\n\n\t\t/**\n\t\t * Is composition from top to bottom?\n\t\t *\n\t\t * @method isCompositionTopToBottom\n\t\t * @return {boolean}\n\t\t */\n\t\tisCompositionTopToBottom: function () {\n\t\t\treturn (this.getCompositionMode() == constants.COMPOSITION_TOP_TO_BOTTOM);\n\t\t},\n\n\t\t/**\n\t\t * Creates a composition according to the configuration\n\t\t *\n\t\t * @method createComposition\n\t\t * @param {PNGImage} imageA\n\t\t * @param {PNGImage} imageB\n\t\t * @param {PNGImage} imageOutput\n\t\t * @return {PNGImage}\n\t\t */\n\t\tcreateComposition: function (imageA, imageB, imageOutput) {\n\n\t\t\tvar width, height, image = imageOutput;\n\n\t\t\tif (!this.isCompositionOff()) {\n\t\t\t\tthis.log('Create composition');\n\n\t\t\t\twidth = Math.max(imageA.getWidth(), imageB.getWidth());\n\t\t\t\theight = Math.max(imageA.getHeight(), imageB.getHeight());\n\n\t\t\t\tif (((width > height) && this.isAutoComposition()) || this.isCompositionTopToBottom()) {\n\t\t\t\t\timage = PNGImage.createImage(width, height * 3);\n\n\t\t\t\t\timageA.getImage().bitblt(image.getImage(), 0, 0, imageA.getWidth(), imageA.getHeight(), 0, 0);\n\t\t\t\t\timageOutput.getImage().bitblt(image.getImage(), 0, 0, imageOutput.getWidth(), imageOutput.getHeight(), 0, height);\n\t\t\t\t\timageB.getImage().bitblt(image.getImage(), 0, 0, imageB.getWidth(), imageB.getHeight(), 0, height * 2);\n\t\t\t\t} else {\n\t\t\t\t\timage = PNGImage.createImage(width * 3, height);\n\n\t\t\t\t\timageA.getImage().bitblt(image.getImage(), 0, 0, imageA.getWidth(), imageA.getHeight(), 0, 0);\n\t\t\t\t\timageOutput.getImage().bitblt(image.getImage(), 0, 0, imageOutput.getWidth(), imageOutput.getHeight(), width, 0);\n\t\t\t\t\timageB.getImage().bitblt(image.getImage(), 0, 0, imageB.getWidth(), imageB.getHeight(), width * 2, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the copy-image mode\n\t\t *\n\t\t * @method getCopyImage\n\t\t * @return {int}\n\t\t */\n\t\tgetCopyImage: function () {\n\t\t\treturn this._copyImage;\n\t\t},\n\n\t\t/**\n\t\t * Sets the copy-image mode\n\t\t *\n\t\t * @method setCopyImage\n\t\t * @param {int} value\n\t\t */\n\t\tsetCopyImage: function (value) {\n\t\t\tthis._copyImage = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Should any image be copied as base for the result?\n\t\t *\n\t\t * @method shouldCopyImage\n\t\t * @return {boolean}\n\t\t */\n\t\tshouldCopyImage: function () {\n\t\t\treturn (this.getCopyImage() != constants.COPY_IMAGE_OFF);\n\t\t},\n\n\t\t/**\n\t\t * Should image A be copied as base of result?\n\t\t *\n\t\t * @method shouldCopyImageA\n\t\t * @return {boolean}\n\t\t */\n\t\tshouldCopyImageA: function () {\n\t\t\treturn (this.getCopyImage() == constants.COPY_IMAGE_A);\n\t\t},\n\n\t\t/**\n\t\t * Should image B be copied as base of result?\n\t\t *\n\t\t * @method shouldCopyImageB\n\t\t * @return {boolean}\n\t\t */\n\t\tshouldCopyImageB: function () {\n\t\t\treturn (this.getCopyImage() == constants.COPY_IMAGE_B);\n\t\t},\n\n\n\t\t/**\n\t\t * Copies the image to the output-image as defined in the configuration\n\t\t *\n\t\t * @method copyImage\n\t\t * @param {PNGImage} imageA\n\t\t * @param {PNGImage} imageB\n\t\t * @param {PNGImage} imageOutput\n\t\t */\n\t\tcopyImage: function (imageA, imageB, imageOutput) {\n\n\t\t\tif (this.shouldCopyImageA()) {\n\t\t\t\timageA.getImage().bitblt(imageOutput.getImage(), 0, 0, imageA.getWidth(), imageA.getHeight(), 0, 0);\n\n\t\t\t} else if (this.shouldCopyImageB()) {\n\t\t\t\timageB.getImage().bitblt(imageOutput.getImage(), 0, 0, imageB.getWidth(), imageB.getHeight(), 0, 0);\n\t\t\t}\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_OUTPUT'\n\t}\n);\n\nmodule.exports = Output;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/image.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('preceptor-core').Base;\nvar PNGImage = require('pngjs-image');\n\n/**\n * @class Image\n * @extends Base\n * @module Compare\n *\n * @property {PNGImage} _image\n * @property {number[]} _refWhite\n * @property {boolean} _gammaCorrection\n * @property {boolean} _perceptual\n * @property {boolean} _filters\n */\nvar Image = Base.extend(\n\n\t/**\n\t * Image constructor\n\t *\n\t * @param {object} options\n\t * @param {PNGImage} options.image Image\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super();\n\n\t\tthis._image = options.image;\n\n\t\tthis._refWhite = [];\n\t\tthis._convertRgbToXyz([1, 1, 1, 1], 0, this._refWhite);\n\n\t\tthis._gammaCorrection = false;\n\t\tthis._perceptual = false;\n\t\tthis._filters = false;\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the image\n\t\t *\n\t\t * @method getImage\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetImage: function () {\n\t\t\treturn this._image;\n\t\t},\n\n\t\t/**\n\t\t * Gets the image data\n\t\t *\n\t\t * @method getData\n\t\t * @return {Buffer}\n\t\t */\n\t\tgetData: function () {\n\t\t\treturn this.getImage()._data;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the width of the image\n\t\t *\n\t\t * @method getWidth\n\t\t * @return {int}\n\t\t */\n\t\tgetWidth: function () {\n\t\t\treturn this.getImage().getWidth();\n\t\t},\n\n\t\t/**\n\t\t * Gets the height of the image\n\t\t *\n\t\t * @method getHeight\n\t\t * @return {int}\n\t\t */\n\t\tgetHeight: function () {\n\t\t\treturn this.getImage().getHeight();\n\t\t},\n\n\t\t/**\n\t\t * Gets the length of bytes of the image\n\t\t *\n\t\t * @method getLength\n\t\t * @return {int}\n\t\t */\n\t\tgetLength: function () {\n\t\t\treturn this.getWidth() * this.getHeight() * 4;\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if gamma-correction has been applied\n\t\t *\n\t\t * @method hasGammaCorrection\n\t\t * @return {boolean}\n\t\t */\n\t\thasGammaCorrection: function () {\n\t\t\treturn this._gammaCorrection;\n\t\t},\n\n\t\t/**\n\t\t * Is image converted to a perceptual image?\n\t\t *\n\t\t * @method isPerceptual\n\t\t * @return {boolean}\n\t\t */\n\t\tisPerceptual: function () {\n\t\t\treturn this._perceptual;\n\t\t},\n\n\t\t/**\n\t\t * Has applied filters\n\t\t *\n\t\t * @method hasFilters\n\t\t * @return {boolean}\n\t\t */\n\t\thasFilters: function () {\n\t\t\treturn this._filters;\n\t\t},\n\n\n\t\t/**\n\t\t * Applies gamma correction on the image\n\t\t *\n\t\t * @method applyGamma\n\t\t * @param {Color} gamma\n\t\t */\n\t\tapplyGamma: function (gamma) {\n\n\t\t\tvar i, len,\n\t\t\t\timage,\n\t\t\t\tlocalGamma;\n\n\t\t\tif (!this._perceptual) {\n\n\t\t\t\tlen = this.getLength();\n\t\t\t\timage = this.getData();\n\t\t\t\tlocalGamma = gamma.getColor();\n\n\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\timage[i] = Math.pow(image[i], 1 / localGamma.red);\n\t\t\t\t\timage[i + 1] = Math.pow(image[i + 1], 1 / localGamma.green);\n\t\t\t\t\timage[i + 2] = Math.pow(image[i + 2], 1 / localGamma.blue);\n\t\t\t\t}\n\n\t\t\t\tthis._gammaCorrection = true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Converts the image to a perceptual color-space\n\t\t *\n\t\t * @method convertToPerceptual\n\t\t */\n\t\tconvertToPerceptual: function () {\n\n\t\t\tvar i, len,\n\t\t\t\tdata,\n\t\t\t\tpixelList,\n\t\t\t\tbounds;\n\n\t\t\tif (!this._perceptual) {\n\n\t\t\t\tlen = this.getLength();\n\t\t\t\tdata = this.getData();\n\t\t\t\tpixelList = [];\n\n\t\t\t\tbounds = [\n\t\t\t\t\t{min: 20000000, max: -20000000},\n\t\t\t\t\t{min: 20000000, max: -20000000},\n\t\t\t\t\t{min: 20000000, max: -20000000}\n\t\t\t\t];\n\n\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\tthis._convertRgbToXyz(data, i, pixelList);\n\t\t\t\t\tthis._convertXyzToCieLab(data, i, pixelList);\n\n\t\t\t\t\tbounds[0].min = Math.min(bounds[0].min, pixelList[i]);\n\t\t\t\t\tbounds[1].min = Math.min(bounds[1].min, pixelList[i + 1]);\n\t\t\t\t\tbounds[2].min = Math.min(bounds[2].min, pixelList[i + 2]);\n\n\t\t\t\t\tbounds[0].max = Math.max(bounds[0].max, pixelList[i]);\n\t\t\t\t\tbounds[1].max = Math.max(bounds[1].max, pixelList[i + 1]);\n\t\t\t\t\tbounds[2].max = Math.max(bounds[2].max, pixelList[i + 2]);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t\t\tdata[i] = 255 * ((pixelList[i] - bounds[0].min) / bounds[0].max);\n\t\t\t\t\tdata[i + 1] = 255 * ((pixelList[i + 1] - bounds[1].min) / bounds[1].max);\n\t\t\t\t\tdata[i + 2] = 255 * ((pixelList[i + 2] - bounds[2].min) / bounds[2].max);\n\t\t\t\t}\n\n\t\t\t\tthis._perceptual = true;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Converts the color from RGB to XYZ\n\t\t *\n\t\t * @method _convertRgbToXyz\n\t\t * @param {Buffer} buffer\n\t\t * @param {int} offset\n\t\t * @param {int[]} output\n\t\t * @private\n\t\t */\n\t\t_convertRgbToXyz: function (buffer, offset, output) {\n\n\t\t\tvar result = [\n\t\t\t\tbuffer[offset] * 0.4887180 + buffer[offset + 1] * 0.3106803 + buffer[offset + 2] * 0.2006017,\n\t\t\t\tbuffer[offset] * 0.1762044 + buffer[offset + 1] * 0.8129847 + buffer[offset + 2] * 0.0108109,\n\t\t\t\tbuffer[offset + 1] * 0.0102048 + buffer[offset + 2] * 0.9897952,\n\t\t\t\tbuffer[offset + 3]\n\t\t\t];\n\n\t\t\toutput[offset] = result[0];\n\t\t\toutput[offset + 1] = result[1];\n\t\t\toutput[offset + 2] = result[2];\n\t\t\toutput[offset + 3] = result[3];\n\t\t},\n\n\t\t/**\n\t\t * Converts the color from Xyz to CieLab\n\t\t *\n\t\t * @method _convertXyzToCieLab\n\t\t * @param {Buffer} buffer\n\t\t * @param {int} offset\n\t\t * @param {int[]} output\n\t\t * @private\n\t\t */\n\t\t_convertXyzToCieLab: function (buffer, offset, output) {\n\n\t\t\tvar c1, c2, c3;\n\n\t\t\tfunction f (t) {\n\t\t\t\treturn (t > 0.00885645167904) ? Math.pow(t, 1 / 3) : 70.08333333333263 * t + 0.13793103448276;\n\t\t\t}\n\n\t\t\tc1 = f(buffer[offset] / this._refWhite[0]);\n\t\t\tc2 = f(buffer[offset + 1] / this._refWhite[1]);\n\t\t\tc3 = f(buffer[offset + 2] / this._refWhite[2]);\n\n\t\t\toutput[offset] = (116 * c2) - 16;\n\t\t\toutput[offset + 1] = 500 * (c1 - c2);\n\t\t\toutput[offset + 2] = 200 * (c2 - c3);\n\t\t\toutput[offset + 3] = buffer[offset + 3];\n\t\t},\n\n\n\t\t/**\n\t\t * Applies a list of filters\n\t\t *\n\t\t * @method applyFilters\n\t\t * @param {string[]} filters\n\t\t */\n\t\tapplyFilters: function (filters) {\n\t\t\tif (!this._filters) {\n\t\t\t\tthis.getImage().applyFilters(filters);\n\t\t\t\tthis._filters = true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Processes image for the comparison configuration\n\t\t *\n\t\t * @method processImage\n\t\t * @param {PixelComparison|StructureComparison} comparison\n\t\t */\n\t\tprocessImage: function (comparison) {\n\n\t\t\tif (comparison.hasGamma && comparison.hasGamma()) {\n\t\t\t\tthis.applyGamma(comparison.getGamma())\n\t\t\t}\n\t\t\tif (comparison.isPerceptual && comparison.isPerceptual()) {\n\t\t\t\tthis.convertToPerceptual();\n\t\t\t}\n\n\t\t\tif (comparison.getFilters) {\n\t\t\t\tthis.applyFilters(comparison.getFilters());\n\t\t\t}\n\n\t\t\tif (comparison.getBlockOuts) { // Important - do this after filtering\n\t\t\t\tcomparison.getBlockOuts().forEach(function (blockOut) {\n\t\t\t\t\tthis._image = blockOut.processImage(this.getImage());\n\t\t\t\t}.bind(this));\n\t\t\t}\n\n\t\t\treturn this.getImage();\n\t\t}\n\t},\n\n\t/**\n\t * @lends Image\n\t */\n\t{\n\t\t/**\n\t\t * Processes an image with comparison configuration\n\t\t *\n\t\t * @param {PNGImage} image\n\t\t * @param {PixelComparison|StructureComparison} comparison\n\t\t * @return {PNGImage}\n\t\t */\n\t\tprocessImage: function (image, comparison) {\n\n\t\t\tvar obj = new Image({\n\t\t\t\timage: image\n\t\t\t});\n\n\t\t\tobj.processImage(comparison);\n\n\t\t\treturn obj.getImage();\n\t\t}\n\t}\n);\n\nmodule.exports = Image;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/pixelComparator.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('preceptor-core').Base;\n\nvar Rect = require('./configuration/atoms/rect');\n\n/**\n * @class PixelComparator\n * @extends Base\n * @module Compare\n *\n * @property {PNGImage} _imageA\n * @property {PNGImage} _imageB\n * @property {Config} _config\n */\nvar PixelComparator = Base.extend(\n\n\t/**\n\t * Constructor for the pixel comparator\n\t *\n\t * @constructor\n\t * @param {PNGImage} imageA\n\t * @param {PNGImage} imageB\n\t * @param {Config} config\n\t */\n\tfunction (imageA, imageB, config) {\n\t\tthis._imageA = imageA;\n\t\tthis._imageB = imageB;\n\t\tthis._config = config;\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets image A\n\t\t *\n\t\t * @method getImageA\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetImageA: function () {\n\t\t\treturn this._imageA;\n\t\t},\n\n\t\t/**\n\t\t * Gets image B\n\t\t *\n\t\t * @method getImageB\n\t\t * @return {PNGImage}\n\t\t */\n\t\tgetImageB: function () {\n\t\t\treturn this._imageB;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the configuration\n\t\t *\n\t\t * @method getConfig\n\t\t * @return {Config}\n\t\t */\n\t\tgetConfig: function () {\n\t\t\treturn this._config;\n\t\t},\n\n\n\t\t/**\n\t\t * Calculates the distance of colors in the 4 dimensional color space\n\t\t *\n\t\t * Note: The distance is squared for faster calculation.\n\t\t *\n\t\t * @method _colorDelta\n\t\t * @param {int} offsetA Offset in first image\n\t\t * @param {int} offsetB Offset in second image\n\t\t * @return {number} Distance\n\t\t * @private\n\t\t */\n\t\t_colorDelta: function (offsetA, offsetB) {\n\n\t\t\tvar imageA = this._imageA.getData(),\n\t\t\t\timageB = this._imageB.getData();\n\n\t\t\treturn Math.pow(imageA[offsetA] - imageB[offsetB], 2) +\n\t\t\t\tMath.pow(imageA[offsetA + 1] - imageB[offsetB + 1], 2) +\n\t\t\t\tMath.pow(imageA[offsetA + 2] - imageB[offsetB + 2], 2) +\n\t\t\t\tMath.pow(imageA[offsetA + 3] - imageB[offsetB + 3], 2);\n\t\t},\n\n\t\t/**\n\t\t * Determines the areas that needs to be compared\n\t\t *\n\t\t * @method _getAreas\n\t\t * @param {PixelComparison} comparison\n\t\t * @return {Rect[]}\n\t\t * @private\n\t\t */\n\t\t_getAreas: function (comparison) {\n\n\t\t\tvar areaA, areaB,\n\t\t\t\tareas = [],\n\t\t\t\timageArea = new Rect({\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t\twidth: this._imageA.getWidth(),\n\t\t\t\t\theight: this._imageA.getHeight()\n\t\t\t\t});\n\n\t\t\tif (!comparison.getAreaImageA() || !comparison.getAreaImageB()) {\n\t\t\t\tareas.push(imageArea);\n\t\t\t\tareas.push(imageArea);\n\n\t\t\t} else {\n\n\t\t\t\tareaA = comparison.getAreaImageA().clone().limitCoordinates(imageArea);\n\t\t\t\tareaB = comparison.getAreaImageB().clone().limitCoordinates(imageArea);\n\n\t\t\t\tareaA.setWidth(Math.min(areaA.getWidth(), areaB.getWidth()));\n\t\t\t\tareaA.setHeight(Math.min(areaA.getHeight(), areaB.getHeight()));\n\n\t\t\t\tareaB.setWidth(areaA.getWidth());\n\t\t\t\tareaB.setHeight(areaA.getHeight());\n\n\t\t\t\tareas.push(areaA);\n\t\t\t\tareas.push(areaB);\n\t\t\t}\n\n\t\t\treturn areas;\n\t\t},\n\n\t\t/**\n\t\t * Compares two images and sets a flags in flag-field\n\t\t *\n\t\t * @method compare\n\t\t * @param {PixelComparison} comparison\n\t\t * @param {Buffer} flagField\n\t\t */\n\t\tcompare: function (comparison, flagField) {\n\n\t\t\tvar flagFieldIndexA, dataIndexA,\n\t\t\t\tflagFieldIndexB, dataIndexB,\n\t\t\t\tx, y, delta,\n\t\t\t\tareas = this._getAreas(comparison),\n\t\t\t\tareaA = areas[0].getCoordinates(),\n\t\t\t\tareaB = areas[1].getCoordinates(),\n\t\t\t\twidth = areaA.width,\n\t\t\t\theight = areaA.height,\n\t\t\t\tdeltaThreshold = comparison.getColorDeltaSquared(),\n\t\t\t\tuseImageB = this.getConfig().getOutput().shouldCopyImageB();\n\n\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\tfor (y = 0; y < height; y++) {\n\n\t\t\t\t\tflagFieldIndexA = (x + areaA.x) + ((y + areaA.y) * width);\n\t\t\t\t\tdataIndexA = 4 * flagFieldIndexA;\n\n\t\t\t\t\tflagFieldIndexB = (x + areaB.x) + ((y + areaB.y) * width);\n\t\t\t\t\tdataIndexB = 4 * flagFieldIndexB;\n\n\t\t\t\t\tdelta = this._colorDelta(dataIndexA, dataIndexB);\n\n\t\t\t\t\tif (delta > deltaThreshold) {\n\n\t\t\t\t\t\tif (this._shiftCompare(x, y, dataIndexA, comparison, this._imageA, areaA, this._imageB, areaB) &&\n\t\t\t\t\t\t\tthis._shiftCompare(x, y, dataIndexB, comparison, this._imageB, areaB, this._imageA, areaA)) {\n\n\t\t\t\t\t\t\tflagField[useImageB ? flagFieldIndexB : flagFieldIndexA] |= 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflagField[useImageB ? flagFieldIndexB : flagFieldIndexA] |= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Comparison, covering sub-pixel shifts\n\t\t *\n\t\t * @method _shiftCompare\n\t\t * @param {int} x X-offset for current comparison coordinate\n\t\t * @param {int} y Y-offset for current comparison coordinate\n\t\t * @param {int} colorIndex Index of color in data\n\t\t * @param {PixelComparison} comparison Comparison configuration\n\t\t * @param {PNGImage} imageSrc Source image\n\t\t * @param {object} areaSrc Area that is compared in source image\n\t\t * @param {PNGImage} imageDst Destination image\n\t\t * @param {object} areaDst Area that is compared in destination image\n\t\t * @return {boolean} Within limits?\n\t\t * @private\n\t\t */\n\t\t_shiftCompare: function (x, y, colorIndex, comparison, imageSrc, areaSrc, imageDst, areaDst) {\n\n\t\t\tvar xOffset, xLow, xHigh,\n\t\t\t\tyOffset, yLow, yHigh,\n\n\t\t\t\tdelta, localDeltaThreshold,\n\t\t\t\tdataIndexSrc, dataIndexDst,\n\n\t\t\t\tdeltaThreshold = comparison.getColorDeltaSquared(),\n\n\t\t\t\tshift = comparison.getShift(),\n\t\t\t\thShift = shift.getHorizontal(),\n\t\t\t\tvShift = shift.getVertical(),\n\n\t\t\t\twidth = areaSrc.width,\n\t\t\t\theight = areaSrc.height;\n\n\n\t\t\tif ((hShift > 0) || (vShift > 0)) {\n\n\t\t\t\txLow = this._calculateLowerLimit(x, 0, hShift);\n\t\t\t\txHigh = this._calculateUpperLimit(x, width - 1, hShift);\n\n\t\t\t\tyLow = this._calculateLowerLimit(y, 0, vShift);\n\t\t\t\tyHigh = this._calculateUpperLimit(y, height - 1, vShift);\n\n\t\t\t\tfor (xOffset = xLow; xOffset <= xHigh; xOffset++) {\n\t\t\t\t\tfor (yOffset = yLow; yOffset <= yHigh; yOffset++) {\n\n\t\t\t\t\t\tif ((xOffset != 0) || (yOffset != 0)) {\n\n\t\t\t\t\t\t\tdataIndexSrc = ((x + areaSrc.x + xOffset) + ((y + areaSrc.y + yOffset) * width)) * 4;\n\t\t\t\t\t\t\tlocalDeltaThreshold = this._colorDelta(colorIndex, dataIndexSrc);\n\n\t\t\t\t\t\t\tdataIndexDst = ((x + areaDst.x + xOffset) + ((y + areaDst.y + yOffset) * width)) * 4;\n\t\t\t\t\t\t\tdelta = this._colorDelta(colorIndex, dataIndexDst);\n\n\t\t\t\t\t\t\tif ((Math.abs(delta - localDeltaThreshold) < deltaThreshold) &&\n\t\t\t\t\t\t\t\t(localDeltaThreshold > deltaThreshold)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * Calculates the lower limit\n\t\t *\n\t\t * @method _calculateLowerLimit\n\t\t * @param {int} value\n\t\t * @param {int} min\n\t\t * @param {int} shift\n\t\t * @return {int}\n\t\t * @private\n\t\t */\n\t\t_calculateLowerLimit: function (value, min, shift) {\n\t\t\treturn (value - shift) < min ? -(shift + (value - shift)) : -shift;\n\t\t},\n\n\t\t/**\n\t\t * Calculates the upper limit\n\t\t *\n\t\t * @method _calculateUpperLimit\n\t\t * @param {int} value\n\t\t * @param {int} max\n\t\t * @param {int} shift\n\t\t * @return {int}\n\t\t * @private\n\t\t */\n\t\t_calculateUpperLimit: function (value, max, shift) {\n\t\t\treturn (value + shift) > max ? (max - value) : shift;\n\t\t}\n\t}\n);\n\nmodule.exports = PixelComparator;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/compatibility.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('preceptor-core').Base;\n\nvar constants = require('./constants');\nvar assert = require('assert');\n\n/**\n * @class Compatibility\n * @extends Base\n * @module Compare\n *\n * @property {object} _options\n */\nvar Compatibility = Base.extend(\n\n\t/**\n\t * Constructor for the compatibility object\n\t *\n\t * @constructor\n\t * @param {object} options\n\t * @param {PNGImage|Buffer} options.imageA Image object of first image\n\t * @param {string} options.imageAPath Path to first image\n\t * @param {PNGImage|Buffer} options.imageB Image object of second image\n\t * @param {string} options.imageBPath Path to second image\n\t * @param {string} [options.imageOutputPath=undefined] Path to output image file\n\t * @param {int} [options.imageOutputLimit=constants.OUTPUT_ALL] Determines when an image output is created\n\t * @param {string} [options.thresholdType=constants.THRESHOLD_PIXEL] Defines the threshold of the comparison\n\t * @param {int} [options.threshold=500] Threshold limit according to the comparison limit.\n\t * @param {number} [options.delta=20] Distance between the color coordinates in the 4 dimensional color-space that will not trigger a difference.\n\t * @param {int} [options.outputMaskRed=255] Value to set for red on difference pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputMaskGreen=0] Value to set for green on difference pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputMaskBlue=0] Value to set for blue on difference pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputMaskAlpha=255] Value to set for the alpha channel on difference pixel. 'Undefined' will not change the value.\n\t * @param {float} [options.outputMaskOpacity=0.7] Strength of masking the pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n\t * @param {int} [options.outputShiftRed=255] Value to set for red on shifted pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputShiftGreen=165] Value to set for green on shifted pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputShiftBlue=0] Value to set for blue on shifted pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.outputShiftAlpha=255] Value to set for the alpha channel on shifted pixel. 'Undefined' will not change the value.\n\t * @param {float} [options.outputShiftOpacity=0.7] Strength of masking the shifted pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n\t * @param {int} [options.outputBackgroundRed=0] Value to set for red as background. 'Undefined' will not change the value.\n\t * @param {int} [options.outputBackgroundGreen=0] Value to set for green as background. 'Undefined' will not change the value.\n\t * @param {int} [options.outputBackgroundBlue=0] Value to set for blue as background. 'Undefined' will not change the value.\n\t * @param {int} [options.outputBackgroundAlpha=undefined] Value to set for the alpha channel as background. 'Undefined' will not change the value.\n\t * @param {float} [options.outputBackgroundOpacity=0.6] Strength of masking the pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n\t * @param {object|object[]} [options.blockOut] Object or list of objects with coordinates of blocked-out areas.\n\t * @param {int} [options.blockOutRed=0] Value to set for red on blocked-out pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.blockOutGreen=0] Value to set for green on blocked-out pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.blockOutBlue=0] Value to set for blue on blocked-out pixel. 'Undefined' will not change the value.\n\t * @param {int} [options.blockOutAlpha=255] Value to set for the alpha channel on blocked-out pixel. 'Undefined' will not change the value.\n\t * @param {float} [options.blockOutOpacity=1.0] Strength of masking the blocked-out pixel. 1.0 means that the full color will be used; anything less will mix-in the original pixel.\n\t * @param {boolean} [options.copyImageAToOutput=true]  Copies the first image to the output image before the comparison begins. This will make sure that the output image will highlight the differences on the first image.\n\t * @param {boolean} [options.copyImageBToOutput=false] Copies the second image to the output image before the comparison begins. This will make sure that the output image will highlight the differences on the second image.\n\t * @param {string[]} [options.filter=[]] Filters that will be applied before the comparison. Available filters are: blur, grayScale, lightness, luma, luminosity, sepia\n\t * @param {boolean} [options.debug=false] When set, then the applied filters will be shown on the output image.\n\t * @param {boolean} [options.composition=true] Should a composition be created to compare?\n\t * @param {boolean} [options.composeLeftToRight=false] Create composition from left to right, otherwise let it decide on its own whats best\n\t * @param {boolean} [options.composeTopToBottom=false] Create composition from top to bottom, otherwise let it decide on its own whats best\n\t * @param {boolean} [options.hideShift=false] Hides shift highlighting by using the background color instead\n\t * @param {int} [options.hShift=2] Horizontal shift for possible antialiasing\n\t * @param {int} [options.vShift=2] Vertical shift for possible antialiasing\n\t * @param {object} [options.cropImageA=null] Cropping for first image (default: no cropping)\n\t * @param {int} [options.cropImageA.x=0] Coordinate for left corner of cropping region\n\t * @param {int} [options.cropImageA.y=0] Coordinate for top corner of cropping region\n\t * @param {int} [options.cropImageA.width] Width of cropping region (default: Width that is left)\n\t * @param {int} [options.cropImageA.height] Height of cropping region (default: Height that is left)\n\t * @param {object} [options.cropImageB=null] Cropping for second image (default: no cropping)\n\t * @param {int} [options.cropImageB.x=0] Coordinate for left corner of cropping region\n\t * @param {int} [options.cropImageB.y=0] Coordinate for top corner of cropping region\n\t * @param {int} [options.cropImageB.width] Width of cropping region (default: Width that is left)\n\t * @param {int} [options.cropImageB.height] Height of cropping region (default: Height that is left)\n\t * @param {boolean} [options.perceptual=false] Turns perceptual comparison on\n\t * @param {float} [options.gamma] Gamma correction for all colors\n\t * @param {float} [options.gammaR] Gamma correction for red\n\t * @param {float} [options.gammaG] Gamma correction for green\n\t * @param {float} [options.gammaB] Gamma correction for blue\n\t */\n\tfunction (options) {\n\t\tthis._options = options;\n\t},\n\n\t{\n\t\t/**\n\t\t * Generates a configuration object\n\t\t *\n\t\t * @method generate\n\t\t * @return {object}\n\t\t */\n\t\tgenerate: function () {\n\n\t\t\tvar options = this._options,\n\t\t\t\tblockOuts,\n\t\t\t\tcomparison,\n\t\t\t\tconfig;\n\n\t\t\tassert.ok(options.imageAPath || options.imageA, \"Image A not given.\");\n\t\t\tassert.ok(options.imageBPath || options.imageB, \"Image B not given.\");\n\n\t\t\toptions.blockOut = options.blockOut || [];\n\t\t\tif (typeof options.blockOut != 'object' && (options.blockOut.length !== undefined)) {\n\t\t\t\toptions.blockOut = [options.blockOut];\n\t\t\t}\n\n\t\t\tblockOuts = [];\n\t\t\toptions.blockOut.forEach(function (blockOut) {\n\t\t\t\tblockOuts.push({\n\t\t\t\t\tvisible: true,\n\t\t\t\t\tarea: {\n\t\t\t\t\t\tleft: blockOut.x,\n\t\t\t\t\t\ttop: blockout.y,\n\t\t\t\t\t\twidth: blockout.width,\n\t\t\t\t\t\theight: blockout.height\n\t\t\t\t\t},\n\t\t\t\t\tcolor: {\n\t\t\t\t\t\tred: options.blockOutRed || 0,\n\t\t\t\t\t\tgreen: options.blockOutGreen || 0,\n\t\t\t\t\t\tblue: options.blockOutBlue || 0,\n\t\t\t\t\t\talpha: options.blockOutAlpha || 255,\n\t\t\t\t\t\topacity: options.blockOutOpacity || 1.0\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcomparison = {\n\t\t\t\ttype: 'pixel',\n\t\t\t\tcolorDelta: options.delta || 20,\n\n\t\t\t\tgamma: {\n\t\t\t\t\tred: options.gamma || options.gammaR,\n\t\t\t\t\tgreen: options.gamma || options.gammaG,\n\t\t\t\t\tblue: options.gamma || options.gammaB\n\t\t\t\t},\n\t\t\t\tperceptual: !!options.perceptual,\n\t\t\t\tfilters: options.filter || [],\n\n\t\t\t\tshift: {\n\t\t\t\t\tactive: !options.hideShift,\n\t\t\t\t\thorizontal: options.hShift || 2,\n\t\t\t\t\tvertical: options.vShift || 2\n\t\t\t\t},\n\n\t\t\t\tblockOuts: blockOuts,\n\n\t\t\t\tareaImageA: {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth: null,\n\t\t\t\t\theight: null\n\t\t\t\t},\n\t\t\t\tareaImageB: {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth: null,\n\t\t\t\t\theight: null\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconfig = {\n\n\t\t\t\tdebug: !!options.debug,\n\t\t\t\tverbose: !!options.debug,\n\n\t\t\t\timageA: {\n\t\t\t\t\timage: options.imageA || options.imageAPath,\n\t\t\t\t\tcrop: undefined\n\t\t\t\t},\n\t\t\t\timageB: {\n\t\t\t\t\timage: options.imageB || options.imageBPath,\n\t\t\t\t\tcrop: undefined\n\t\t\t\t},\n\n\t\t\t\tcomparisons: [ comparison ],\n\n\t\t\t\tthreshold: {\n\t\t\t\t\ttype: options.thresholdType || constants.THRESHOLD_PIXEL,\n\t\t\t\t\tvalue: options.threshold || 500\n\t\t\t\t},\n\n\t\t\t\tdiffColor: {\n\t\t\t\t\tred: options.outputMaskRed || 255,\n\t\t\t\t\tgreen: options.outputMaskGreen || 0,\n\t\t\t\t\tblue: options.outputMaskBlue || 0,\n\t\t\t\t\talpha: options.outputMaskAlpha || 255,\n\t\t\t\t\topacity: options.outputMaskOpacity || 0.7\n\t\t\t\t},\n\n\t\t\t\tbackgroundColor: {\n\t\t\t\t\tred: options.outputBackgroundRed || 0,\n\t\t\t\t\tgreen: options.outputBackgroundGreen || 0,\n\t\t\t\t\tblue: options.outputBackgroundBlue || 0,\n\t\t\t\t\talpha: options.outputBackgroundAlpha,\n\t\t\t\t\topacity: options.outputBackgroundOpacity || 0.6\n\t\t\t\t},\n\t\t\t\tignoreColor: {\n\t\t\t\t\tred: options.outputShiftRed || 200,\n\t\t\t\t\tgreen: options.outputShiftGreen || 100,\n\t\t\t\t\tblue: options.outputShiftBlue || 0,\n\t\t\t\t\talpha: options.outputShiftAlpha || 255,\n\t\t\t\t\topacity: options.outputShiftOpacity || 0.7\n\t\t\t\t},\n\n\t\t\t\toutput: {\n\t\t\t\t\timagePath: options.imageOutputPath,\n\t\t\t\t\tlimit: options.imageOutputLimit || constants.OUTPUT_ALL,\n\t\t\t\t\tcomposition: options.composeLeftToRight ? constants.COMPOSITION_LEFT_TO_RIGHT : (options.composeTopToBottom ? constants.COMPOSITION_TOP_TO_BOTTOM : constants.COMPOSITION_AUTO),\n\t\t\t\t\tcopyImage: options.copyImageBToOutput ? constants.COPY_IMAGE_B : constants.COPY_IMAGE_A\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (options.cropImageA) {\n\t\t\t\tconfig.imageA.crop = {\n\t\t\t\t\tleft: options.cropImageA.x,\n\t\t\t\t\ttop: options.cropImageA.y,\n\t\t\t\t\twidth: options.cropImageA.width,\n\t\t\t\t\theight: options.cropImageA.height\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (options.cropImageB) {\n\t\t\t\tconfig.imageB.crop = {\n\t\t\t\t\tleft: options.cropImageB.x,\n\t\t\t\t\ttop: options.cropImageB.y,\n\t\t\t\t\twidth: options.cropImageB.width,\n\t\t\t\t\theight: options.cropImageB.height\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn config;\n\t\t}\n\t}\n);\n\nmodule.exports = Compatibility;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/defaultConfig.js":"module.exports = {\n\n\tdebug: true,\n\tverbose: false,\n\n\timageA: {\n\t\timage: \"\",\n\t\tcrop: {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: 100,\n\t\t\theight: 100\n\t\t}\n\t},\n\timageB: {\n\t\timage: \"\",\n\t\tcrop: {\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\twidth: 100,\n\t\t\theight: 100\n\t\t}\n\t},\n\n\tcomparisons: [\n\t\t{\n\t\t\ttype: 'structure',\n\n\t\t\tselector: \"body div.test\", // *\n\n\t\t\tanchors:[\n\t\t\t\t{\n\t\t\t\t\ttype: \"width\", // height, left, right, top, bottom, horizontal, vertical\n\t\t\t\t\tposition: \"absolute\", // relative\n\t\t\t\t\tthreshold: {\n\t\t\t\t\t\ttype: 'pixel',\n\t\t\t\t\t\tvalue: 5\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\n\t\t\tlimits: [\n\t\t\t\t{\n\t\t\t\t\ttype: \"min\", // max\n\t\t\t\t\tcontext: \"width\", // height\n\t\t\t\t\tvalue: 50\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttype: 'pixel',\n\t\t\tcolorDelta: 5,\n\n\t\t\tgamma: {\n\t\t\t\tred: 0,\n\t\t\t\tgreen: 0,\n\t\t\t\tblue: 0\n\t\t\t},\n\t\t\tperceptual: true,\n\t\t\tfilters: ['blur'],\n\n\t\t\tshift: {\n\t\t\t\tactive: true,\n\t\t\t\thorizontal: 2,\n\t\t\t\tvertical: 2,\n\t\t\t\tvisible: true\n\t\t\t},\n\n\t\t\tblockOuts: [\n\t\t\t\t{\n\t\t\t\t\tvisible: true,\n\t\t\t\t\tarea: {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: 100,\n\t\t\t\t\t\theight: 100\n\t\t\t\t\t},\n\t\t\t\t\tcolor: {\n\t\t\t\t\t\tred: 0,\n\t\t\t\t\t\tgreen: 0,\n\t\t\t\t\t\tblue: 0,\n\t\t\t\t\t\talpha: 0,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t],\n\n\t\t\tareaImageA: {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\twidth: null,\n\t\t\t\theight: null\n\t\t\t},\n\t\t\tareaImageB: {\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0,\n\t\t\t\twidth: null,\n\t\t\t\theight: null\n\t\t\t}\n\t\t}\n\t],\n\n\tthreshold: {\n\t\ttype: 'pixel',\n\t\tvalue: 500\n\t},\n\n\tdiffColor: {\n\t\tred: 0,\n\t\tgreen: 0,\n\t\tblue: 0,\n\t\talpha: 0,\n\t\topacity: 0\n\t},\n\n\tbackgroundColor: {\n\t\tred: 0,\n\t\tgreen: 0,\n\t\tblue: 0,\n\t\talpha: 0,\n\t\topacity: 0\n\t},\n\tignoreColor: {\n\t\tred: 0,\n\t\tgreen: 0,\n\t\tblue: 0,\n\t\talpha: 0,\n\t\topacity: 0\n\t},\n\n\toutput: {\n\t\timagePath: \"\",\n\t\tlimit: OUTPUT_DIFFERENT,\n\t\tcomposition: COMPOSITION_AUTO,\n\t\tcopyImage: COPY_IMAGE_A\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/configuration/anchor.js":"// Copyright 2015 Yahoo! Inc.\n// Copyrights licensed under the Mit License. See the accompanying LICENSE file for terms.\n\nvar Base = require('./base');\nvar utils = require('preceptor-core').utils;\n\nvar Threshold = require('./atoms/threshold');\n\nvar constants = require('../constants');\n\n/**\n * @class Anchor\n * @extends Base\n * @module Configuration\n *\n * @property {string} _type\n * @property {string} _position\n * @property {Threshold} _threshold\n */\nvar Anchor = Base.extend(\n\n\t/**\n\t * Anchor constructor\n\t *\n\t * @param {object} options\n\t * @param {string} options.type\n\t * @param {string} options.position\n\t * @param {object|Threshold} options.threshold\n\t * @constructor\n\t */\n\tfunction (options) {\n\t\tthis.__super(options);\n\n\t\toptions = utils.deepExtend({\n\t\t\ttype: constants.ANCHOR_TYPE_WIDTH,\n\t\t\tposition: constants.ANCHOR_POSITION_RELATIVE,\n\t\t\tthreshold: {}\n\t\t}, [options]);\n\n\t\tthis.setType(options.type);\n\t\tthis.setPositioning(options.position);\n\t\tthis.setThreshold(options.threshold);\n\t},\n\n\t{\n\t\t/**\n\t\t * Gets the type of the anchor\n\t\t *\n\t\t * @method getType\n\t\t * @return {string}\n\t\t */\n\t\tgetType: function () {\n\t\t\treturn this._type;\n\t\t},\n\n\t\t/**\n\t\t * Sets the type of the anchor\n\t\t *\n\t\t * @method setType\n\t\t * @param {string} value\n\t\t */\n\t\tsetType: function (value) {\n\t\t\tthis._type = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the positioning of the anchor\n\t\t *\n\t\t * @method getPositioning\n\t\t * @return {string}\n\t\t */\n\t\tgetPositioning: function () {\n\t\t\treturn this._position;\n\t\t},\n\n\t\t/**\n\t\t * Sets the positioning of the anchor\n\t\t *\n\t\t * @method setPositioning\n\t\t * @param {string} value\n\t\t */\n\t\tsetPositioning: function (value) {\n\t\t\tthis._position = value;\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the threshold\n\t\t *\n\t\t * @method getThreshold\n\t\t * @return {Threshold}\n\t\t */\n\t\tgetThreshold: function () {\n\t\t\treturn this._threshold;\n\t\t},\n\n\t\t/**\n\t\t * Sets the threshold\n\t\t *\n\t\t * @method setThreshold\n\t\t * @param {object|Threshold} value\n\t\t */\n\t\tsetThreshold: function (value) {\n\t\t\tthis._threshold = this._parseObject(value, Threshold, \"threshold\");\n\t\t}\n\t},\n\n\t{\n\t\t/**\n\t\t * @property TYPE\n\t\t * @type {string}\n\t\t * @static\n\t\t */\n\t\tTYPE: 'CONFIGURATION_ANCHOR'\n\t}\n);\n\nmodule.exports = Anchor;\n","/home/travis/build/npmtest/node-npmtest-blink-diff/node_modules/blink-diff/lib/scripts/structure.js":"module.exports = function () {\n\n\tfunction versionInfo () {\n\t\treturn {\n\t\t\tmajor: 1,\n\t\t\tminor: 0\n\t\t};\n\t}\n\n\tfunction deviceInfo () {\n\t\treturn {\n\t\t\tuserAgent: window.navigator.userAgent,\n\n\t\t\tapp: {\n\t\t\t\tcodeName: window.navigator.appCodeName,\n\t\t\t\tname: window.navigator.appName,\n\t\t\t\tversion: window.navigator.appVersion,\n\t\t\t\tbuildId: window.navigator.buildID\n\t\t\t},\n\n\t\t\tlanguages: window.navigator.languages || [window.navigator.language],\n\n\t\t\tproduct: {\n\t\t\t\tname: window.navigator.product,\n\t\t\t\tsub: window.navigator.productSub\n\t\t\t},\n\t\t\tvendor: {\n\t\t\t\tname: window.navigator.vendor,\n\t\t\t\tsub: window.navigator.vendorSub\n\t\t\t},\n\n\t\t\tscreen: {\n\t\t\t\tpixelRatio: window.devicePixelRatio || 1,\n\t\t\t\tcolorDepth: window.screen.colorDepth,\n\t\t\t\twidth: Math.min(window.screen.width, window.screen.availWidth),\n\t\t\t\theight: Math.min(window.screen.height, window.screen.availHeight),\n\t\t\t\tfullScreen: window.fullScreen\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction documentInfo () {\n\t\tvar de = document.documentElement,\n\t\t\tbody = document.body,\n\t\t\tresult = {};\n\n\t\tresult.title = document.title;\n\t\tresult.url = window.location + '';\n\t\tresult.referrer = document.referrer;\n\n\t\tresult.size = {\n\t\t\twidth: Math.max(body.scrollWidth, body.offsetWidth, de.clientWidth, de.scrollWidth, de.offsetWidth),\n\t\t\theight: Math.max(body.scrollHeight, body.offsetHeight, de.clientHeight, de.scrollHeight, de.offsetHeight)\n\t\t}\n\t}\n\n\tfunction viewPortInfo () {\n\t\tvar el = document.createElement('div'),\n\t\t\tde = document.documentElement,\n\t\t\tbody = document.body,\n\t\t\tresult = {};\n\n\t\t// Get current scroll-position\n\t\tresult.x = window.pageXOffset || body.scrollLeft || de.scrollLeft;\n\t\tresult.y = window.pageYOffset || body.scrollTop || de.scrollTop;\n\n\t\t// Get current view-port size\n\t\tel.style.position = \"fixed\";\n\t\tel.style.top = 0;\n\t\tel.style.left = 0;\n\t\tel.style.bottom = 0;\n\t\tel.style.right = 0;\n\t\tde.insertBefore(el, de.firstChild);\n\t\tresult.width = el.offsetWidth;\n\t\tresult.height = el.offsetHeight;\n\t\tde.removeChild(el);\n\n\t\treturn result;\n\t}\n\n\tfunction domInfo () {\n\n\t\tvar capturedTags = [\"A\", \"SPAN\", \"OL\", \"UL\", \"LI\", \"HEADER\", \"FOOTER\", \"NAV\", \"ARTICLE\", \"SECTION\", \"ASIDE\", \"DIV\", \"APPLET\", \"CANVAS\", \"VIDEO\", \"TABLE\", \"DETAILS\", \"SUMMARY\", \"IFRAME\", \"MENU\", \"MAIN\", \"FIGURE\", \"FIELDSET\"];\n\n\t\tfunction loadDOMNode (inputNode, parentNode) {\n\n\t\t\tvar nodes, length, offset, newNode;\n\n\t\t\tif (capturedTags.indexOf(inputNode.tagName) !== -1) {\n\n\t\t\t\tnewNode = {};\n\t\t\t\tnewNode.id = (inputNode.id && inputNode.id.length > 0) ? inputNode.id : null;\n\t\t\t\tnewNode.tagName = inputNode.tagName;\n\t\t\t\tnewNode.classes = (inputNode.className && inputNode.className.length > 0) ? inputNode.className.split(/\\s/) : [];\n\n\t\t\t\toffset = absoluteOffset(inputNode);\n\t\t\t\tnewNode.rect = {\n\t\t\t\t\tx: offset.x,\n\t\t\t\t\ty: offset.y,\n\t\t\t\t\twidth: inputNode.offsetWidth,\n\t\t\t\t\theight: inputNode.offsetHeight\n\t\t\t\t};\n\n\t\t\t\tnewNode.nodes = [];\n\n\t\t\t\tif ((newNode.rect.width > 0) && (newNode.rect.height > 0)) {\n\t\t\t\t\tparentNode.nodes.push(newNode);\n\t\t\t\t\tparentNode = newNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnodes = inputNode.children;\n\t\t\tlength = inputNode.childElementCount;\n\n\t\t\tif (nodes && length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tloadDOMNode(nodes[i], parentNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction absoluteOffset (element) {\n\n\t\t\tvar x = 0, y = 0;\n\n\t\t\tdo {\n\t\t\t\tx += element.offsetLeft || 0;\n\t\t\t\ty += element.offsetTop || 0;\n\t\t\t\telement = element.offsetParent;\n\t\t\t} while (element);\n\n\t\t\treturn {\n\t\t\t\tx: x, y: y\n\t\t\t};\n\t\t}\n\n\t\tvar node = {nodes:[]};\n\n\t\tloadDOMNode(document.body, node);\n\n\t\treturn node.nodes[0];\n\t}\n\n\treturn JSON.stringify({\n\t\tversion: versionInfo(),\n\t\tdevice: deviceInfo(),\n\t\tdocument: documentInfo(),\n\t\tviewPort: viewPortInfo(),\n\t\tscreenshot: {\n\t\t\tstitched: false,\n\t\t\tsection: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\twidth: null,\n\t\t\t\theight: null\n\t\t\t}\n\t\t},\n\t\tdom: domInfo()\n\t});\n};\n"}